\chapter{深入理解程序的执行}
\section{pyc 文件结构}
在本小节当中主要给大家介绍一下 .py 文件在被编译之后对应的 pyc 文件结构，pyc 文件当中的一个核心内容就是 python 字节码。
\subsection{pyc 文件}
pyc 文件是 Python 在解释执行源代码时生成的一种字节码文件，它包含了源代码的编译结果和相关的元数据信息，以便于 Python 可以更快地加载和执行代码。
Python 是一种解释型语言，它不像编译型语言那样将源代码直接编译成机器码执行。Python 的解释器会在运行代码之前先将源代码编译成字节码，然后将字节码解释执行。.pyc 文件就是这个过程中生成的字节码文件。
当 Python 解释器首次执行一个 .py 文件时，它会在同一目录下生成一个对应的 .pyc 文件，以便于下次加载该文件时可以更快地执行。如果源文件在修改之后被重新加载，解释器会重新生成 .pyc 文件以更新缓存的字节码。
\subsection{生成 pyc 文件}
正常的 python 文件需要通过编译器变成字节码，然后将字节码交给 python 虚拟机，然后 python 虚拟机会执行字节码。整体流程如下所示：

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/35-pyc.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
我们可以直接使用 compile all 模块生成对应文件的 pyc 文件。
\begin{lstlisting}[style=cpp,caption=, language=C++]

➜  pvm ls
demo.py  hello.py
➜  pvm python -m compileall .
Listing '.'...
Listing './.idea'...
Listing './.idea/inspectionProfiles'...
Compiling './demo.py'...
Compiling './hello.py'...
➜  pvm ls
__pycache__ demo.py     hello.py
➜  pvm ls __pycache__ 
demo.cpython-310.pyc  hello.cpython-310.pyc
\end{lstlisting}
\verb|python -m compileall .| 命令将递归扫描当前目录下面的 py 文件，并且生成对应文件的 pyc 文件。
\subsection{pyc 文件布局}

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.35]{images/38-pyc.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
第一部分魔数由两部分组成：

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.3]{images/37-pyc.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
第一部分 魔术是由一个 2 字节的整数和另外两个字符回车换行组成的， \verb|"\r\n"|  也占用两个字节，一共是四个字节。这个两个字节的整数在不同的 python 版本还不一样，比如说在 python3.5 当中这个值为 3351 等值，在 python3.9 当中这个值为 3420，3421，3422，3423，3424等值（在 python 3.9 的小版本）。

第二部分 Bit Field 这个字段的主要作用是为了将来能够实现复现编译结果，但是在 python3.9a2 时，这个字段的值还全部是 0 。详细内容可以参考 [PEP552-Deterministic pycs]\footnote{\href{https://peps.python.org/pep-0552/}{https://peps.python.org/pep-0552/}} 。这个字段在 python2 和 python3 早期版本并没有（python3.5 还没有），在 python3 的后期版本这个字段才出现的。

第三部分 就是整个 py  源文件的大小了。

第四部分 也是整个 pyc 文件当中最重要的一个部分，最后一个部分就是一个 CodeObject 对象序列化之后的数据，我们稍后再来仔细分析一下这个对象相关的数据。

我们现在来具体分析一个 pyc 文件，对应的 python 代码为：
\begin{lstlisting}[style=py,caption=, language=Python]

def f():
    x = 1
    return 2
\end{lstlisting}
pyc 文件的十六进制形式如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

➜  __pycache__ hexdump -C hello.cpython-310.pyc
00000000  6f 0d 0d 0a 00 00 00 00  b9 48 21 64 20 00 00 00  |o........H!d ...|
00000010  e3 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000020  00 02 00 00 00 40 00 00  00 73 0c 00 00 00 64 00  |.....@...s....d.|
00000030  64 01 84 00 5a 00 64 02  53 00 29 03 63 00 00 00  |d...Z.d.S.).c...|
00000040  00 00 00 00 00 00 00 00  00 01 00 00 00 01 00 00  |................|
00000050  00 43 00 00 00 73 08 00  00 00 64 01 7d 00 64 02  |.C...s....d.}.d.|
00000060  53 00 29 03 4e e9 01 00  00 00 e9 02 00 00 00 a9  |S.).N...........|
00000070  00 29 01 da 01 78 72 03  00 00 00 72 03 00 00 00  |.)...xr....r....|
00000080  fa 0a 2e 2f 68 65 6c 6c  6f 2e 70 79 da 01 66 01  |.hello.py..f.|
00000090  00 00 00 73 04 00 00 00  04 01 04 01 72 06 00 00  |...s........r...|
000000a0  00 4e 29 01 72 06 00 00  00 72 03 00 00 00 72 03  |.N).r....r....r.|
000000b0  00 00 00 72 03 00 00 00  72 05 00 00 00 da 08 3c  |...r....r......<|
000000c0  6d 6f 64 75 6c 65 3e 01  00 00 00 73 02 00 00 00  |module>....s....|
000000d0  0c 00                                             |..|
000000d2
\end{lstlisting}
因为数据使用小端表示方式，因此对于上面的数据来说：
\begin{itemize}
\item 第一部分魔数为：0xa0d0d6f 。 
\item 第二部分 Bit Field 为：0x0 。 
\item 第三部分最后一次修改日期为：0x642148b9 。 
\item 第四部分文件大小为：0x20 字节，也就是说 hello.py 这个文件的大小是 32 字节。 
\end{itemize}
下面是一个小的代码片段用于读取 pyc 文件的头部元信息：
\begin{lstlisting}[style=py,caption=, language=Python]

import struct
import time
import binascii
fname = "./__pycache__/hello.cpython-310.pyc"
f = open(fname, "rb")
magic = struct.unpack('<l', f.read(4))[0]
bit_filed = f.read(4)
print(f"bit field = {binascii.hexlify(bit_filed)}")
moddate = f.read(4)
filesz = f.read(4)
modtime = time.asctime(time.localtime(struct.unpack('<l', moddate)[0]))
filesz = struct.unpack('<L', filesz)
print("magic %s" % (hex(magic)))
print("moddate (%s)" % (modtime))
print("File Size %d" % filesz)
f.close()
\end{lstlisting}
上面的代码输出结果如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

bit field = b'00000000'
magic 0xa0d0d6f
moddate (Mon Mar 27 15:41:45 2023)
File Size 32
\end{lstlisting}
有关 pyc 文件的详细操作可以查看 python 标准库 importlib/\_bootstrap\_external.py 文件源代码。
\subsection{CodeObject}
在 CPython 中，\verb|CodeObject| 是一个对象，它包含了 Python 代码的字节码、常量、变量、位置参数、关键字参数等信息，以及一些用于运行代码的元数据，如文件名、代码行号等。
在 CPython 中，当我们执行一个 Python 模块或函数时，解释器会先将其代码编译为 \verb|CodeObject|，然后再执行。在编译过程中，解释器会将 Python 代码转换为字节码，并将其保存在 \verb|CodeObject| 对象中。此后，每当我们调用该模块或函数时，解释器都会使用 \verb|CodeObject| 中的字节码来执行代码。
\verb|CodeObject| 对象是不可变的，一旦创建就不能被修改。这是因为 Python 代码的字节码是不可变的，而 \verb|CodeObject| 对象包含了这些字节码，所以也是不可变的。
在本小节当中主要介绍 code object 当中主要的内容，以及简单介绍他们的作用，在后续的文章当中会仔细分析 code object 对应的源代码以及对应的字段的详细作用。
现在举一个例子来分析一下 pycdemo.py 的 pyc 文件，pycdemo.py 的源程序如下所示：
\begin{lstlisting}[style=py,caption=, language=Python]

if __name__ == '__main__':
    a = 100
    print(a)
\end{lstlisting}
下面的代码是一个用于加载 pycdemo01.cpython-39.pyc 文件（也就是 hello.py 对应的 pyc 文件）的代码，使用 marshal 读取 pyc 文件里面的 code object 。
\begin{lstlisting}[style=py,caption=, language=Python]

import marshal
import dis
import struct
import time
import types
import binascii
def print_metadata(fp):
    magic = struct.unpack('<l', fp.read(4))[0]
    print(f"magic number = {hex(magic)}")
    bit_field = struct.unpack('<l', fp.read(4))[0]
    print(f"bit filed = {bit_field}")
    t = struct.unpack('<l', fp.read(4))[0]
    print(f"time = {time.asctime(time.localtime(t))}")
    file_size = struct.unpack('<l', fp.read(4))[0]
    print(f"file size = {file_size}")
def show_code(code, indent=''):
    print ("%scode" % indent)
    indent += '   '
    print ("%sargcount %d" % (indent, code.co_argcount))
    print ("%snlocals %d" % (indent, code.co_nlocals))
    print ("%sstacksize %d" % (indent, code.co_stacksize))
    print ("%sflags %04x" % (indent, code.co_flags))
    show_hex("code", code.co_code, indent=indent)
    dis.disassemble(code)
    print ("%sconsts" % indent)
    for const in code.co_consts:
        if type(const) == types.CodeType:
            show_code(const, indent+'   ')
        else:
            print("   %s%r" % (indent, const))
    print("%snames %r" % (indent, code.co_names))
    print("%svarnames %r" % (indent, code.co_varnames))
    print("%sfreevars %r" % (indent, code.co_freevars))
    print("%scellvars %r" % (indent, code.co_cellvars))
    print("%sfilename %r" % (indent, code.co_filename))
    print("%sname %r" % (indent, code.co_name))
    print("%sfirstlineno %d" % (indent, code.co_firstlineno))
    show_hex("lnotab", code.co_lnotab, indent=indent)
def show_hex(label, h, indent):
    h = binascii.hexlify(h)
    if len(h) < 60:
        print("%s%s %s" % (indent, label, h))
    else:
        print("%s%s" % (indent, label))
        for i in range(0, len(h), 60):
            print("%s   %s" % (indent, h[i:i+60]))
if __name__ == '__main__':
    filename = "./__pycache__/pycdemo01.cpython-39.pyc"
    with open(filename, "rb") as fp:
        print_metadata(fp)
        code_object = marshal.load(fp)
        show_code(code_object)
\end{lstlisting}
执行上面的程序输出结果如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

magic number = 0xa0d0d61
bit filed = 0
time = Tue Mar 28 02:40:20 2023
file size = 54
code
   argcount 0
   nlocals 0
   stacksize 2
   flags 0040
   code b'650064006b02721464015a01650265018301010064025300'
  3           0 LOAD_NAME                0 (__name__)
              2 LOAD_CONST               0 ('__main__')
              4 COMPARE_OP               2 (==)
              6 POP_JUMP_IF_FALSE       20
  4           8 LOAD_CONST               1 (100)
             10 STORE_NAME               1 (a)
  5          12 LOAD_NAME                2 (print)
             14 LOAD_NAME                1 (a)
             16 CALL_FUNCTION            1
             18 POP_TOP
        >>   20 LOAD_CONST               2 (None)
             22 RETURN_VALUE
   consts
      '__main__'
      100
      None
   names ('__name__', 'a', 'print')
   varnames ()
   freevars ()
   cellvars ()
   filename './pycdemo01.py'
   name '<module>'
   firstlineno 3
   lnotab b'08010401'
\end{lstlisting}
下面是 code object 当中各个字段的作用：
\begin{itemize}
\item 首先需要了解一下代码块这个概念，所谓代码块就是一个小的 python 代码，被当做一个小的单元整体执行。在 python 当中常见的代码块块有：函数体、类的定义、一个模块。 
\item argcount，这个表示一个代码块的参数个数，这个参数只对函数体代码块有用，因为函数可能会有参数，比如上面的 pycdemo.py 是一个模块而不是一个函数，因此这个参数对应的值为 0 。 
\item co\_code，这个对象的具体内容就是一个字节序列，存储真实的 python 字节码，主要是用于 python 虚拟机执行的，在本小节当中暂时不详细分析。 
\item co\_consts，这个字段是一个列表类型的字段，主要是包含一些字符串常量和数值常量，比如上面的 "\_\_main\_\_" 和 100 。 
\item co\_filename，这个字段的含义就是对应的源文件的文件名。 
\item co\_firstlineno，这个字段的含义为在 python 源文件当中第一行代码出现的行数，这个字段在进行调试的时候非常重要。 
\item co\_flags，这个字段的主要含义就是标识这个 code object 的类型。0x0080 表示这个 block 是一个协程，0x0010 表示这个 code object 是嵌套的等等。 
\item co\_lnotab，这个字段的含义主要是用于计算每个字节码指令对应的源代码行数。 
\item co\_varnames，这个字段的主要含义是表示在一个 code object 本地定义的一个名字。 
\item co\_names，和 co\_varnames 相反，表示非本地定义但是在 code object 当中使用的名字。 
\item co\_nlocals，这个字段表示在一个 code object 当中本地使用的变量个数。 
\item co\_stackszie，因为 python 虚拟机是一个栈式计算机，这个参数的值表示这个栈需要的最大的值。 
\item co\_cellvars，co\_freevars，这两个字段主要和嵌套函数和函数闭包有关，我们在后续的文章当中将详细解释这个字段。 
\end{itemize}
\subsection{总结}
在本小节当中主要给大家介绍了 python 文件被编译之后的结果文件 .pyc 文件结构，在 pyc 文件当中一个最重要的结构就是 code object 对象，在本小节当中主要是简单介绍了 code object 各个字段的作用。在后续的文章当中将会举详细的例子进行说明，正确理解这些这些字段的含义，对于我们理解 python 虚拟机大有裨益。


\section{字节码灵魂——Code obejct}
在本小节当中主要给大家深入介绍在 cpython 当中非常重要的一个数据结构 code object!在本小节当中将会举一些例子以便更加深入理解这些字段。
\subsection{Code Object 数据结构}
\begin{lstlisting}[style=cpp,caption=, language=C++]

typedef struct {
    PyObject_HEAD
    int co_argcount;		/* #arguments, except *args */
    int co_kwonlyargcount;	/* #keyword only arguments */
    int co_nlocals;		/* #local variables */
    int co_stacksize;		/* #entries needed for evaluation stack */
    int co_flags;		/* CO_..., see below */
    PyObject *co_code;		/* instruction opcodes */
    PyObject *co_consts;	/* list (constants used) */
    PyObject *co_names;		/* list of strings (names used) */
    PyObject *co_varnames;	/* tuple of strings (local variable names) */
    PyObject *co_freevars;	/* tuple of strings (free variable names) */
    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */
    /* The rest aren't used in either hash or comparisons, except for
       co_name (used in both) and co_firstlineno (used only in
       comparisons).  This is done to preserve the name and line number
       for tracebacks and debuggers; otherwise, constant de-duplication
       would collapse identical functions/lambdas defined on different lines.
    */
    unsigned char *co_cell2arg; /* Maps cell vars which are arguments. */
    PyObject *co_filename;	/* unicode (where it was loaded from) */
    PyObject *co_name;		/* unicode (name, for reference) */
    int co_firstlineno;		/* first source line number */
    PyObject *co_lnotab;	/* string (encoding addr<->lineno mapping) See
				   Objects/lnotab_notes.txt for details. */
    void *co_zombieframe;     /* for optimization only (see frameobject.c) */
    PyObject *co_weakreflist;   /* to support weakrefs to code objects */
} PyCodeObject;
\end{lstlisting}
下面是 code object 当中各个字段的作用：
\begin{itemize}
\item 首先需要了解一下代码块这个概念，所谓代码块就是一个小的 python 代码，被当做一个小的单元整体执行。在 python 当中常见的代码块块有：函数体、类的定义、一个模块。 
\item argcount，这个表示一个代码块的参数个数，这个参数只对函数体代码块有用，因为函数可能会有参数，比如上面的 pycdemo.py 是一个模块而不是一个函数，因此这个参数对应的值为 0 。 
\item co\_code，这个对象的具体内容就是一个字节序列，存储真实的 python 字节码，主要是用于 python 虚拟机执行的，在本小节当中暂时不详细分析。 
\item co\_consts，这个字段是一个列表类型的字段，主要是包含一些字符串常量和数值常量，比如上面的 "\_\_main\_\_" 和 100 。 
\item co\_filename，这个字段的含义就是对应的源文件的文件名。 
\item co\_firstlineno，这个字段的含义为在 python 源文件当中第一行代码出现的行数，这个字段在进行调试的时候非常重要。 
\item co\_flags，这个字段的主要含义就是标识这个 code object 的类型。0x0080 表示这个 block 是一个协程，0x0010 表示这个 code object 是嵌套的等等。 
\item co\_lnotab，这个字段的含义主要是用于计算每个字节码指令对应的源代码行数。 
\item co\_varnames，这个字段的主要含义是表示在一个 code object 本地定义的一个名字。 
\item co\_names，和 co\_varnames 相反，表示非本地定义但是在 code object 当中使用的名字。 
\item co\_nlocals，这个字段表示在一个 code object 当中本地使用的变量个数。 
\item co\_stackszie，因为 python 虚拟机是一个栈式计算机，这个参数的值表示这个栈需要的最大的值。 
\item co\_cellvars，co\_freevars，这两个字段主要和嵌套函数和函数闭包有关，我们在后续的文章当中将详细解释这个字段。 
\end{itemize}
\subsection{	CodeObject 详细分析}
现在我们使用一些实际的例子来分析具体的 code object 。
\begin{lstlisting}[style=py,caption=, language=Python]

import dis
import binascii
import types
d = 10
def test_co01(c):
    a = 1
    b = 2
    return a + b + c + d
\end{lstlisting}
在前面的文章当中我们提到过一个函数是包括一个 code object 对象，test\_co01 的 code object 对象的输出结果（完整代码见[co01](https://github.com/Chang-LeHung/dive-into-cpython/blob/master/code/codeobject/co01.py)）如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

code
   argcount 1
   nlocals 3
   stacksize 2
   flags 0043 0x43
   code b'6401007d01006402007d02007c01007c0200177c0000177400001753'
  9           0 LOAD_CONST               1 (1)
              3 STORE_FAST               1 (a)
 10           6 LOAD_CONST               2 (2)
              9 STORE_FAST               2 (b)
 11          12 LOAD_FAST                1 (a)
             15 LOAD_FAST                2 (b)
             18 BINARY_ADD
             19 LOAD_FAST                0 (c)
             22 BINARY_ADD
             23 LOAD_GLOBAL              0 (d)
             26 BINARY_ADD
             27 RETURN_VALUE
   consts
      None
      1
      2
   names ('d',)
   varnames ('c', 'a', 'b')
   freevars ()
   cellvars ()
   filename '/tmp/pycharm_project_396/co01.py'
   name 'test_co01'
   firstlineno 8
   lnotab b'000106010601'
\end{lstlisting}
\begin{itemize}
\item 字段 argcount 的值等于 1，说明函数有一个参数，这个函数 test\_co01 有一个参数 c 是相互对应的。 
\item 字段 nlocals 的值等于 3，说明在函数 test\_co01 当中一个一共实现了三个函数本地变量 a, b, c 。 
\item 字段 names，对应代码代码当中的 co\_names，根据前面的定义就是 d 这个全局变量在函数  test\_co01 当中使用，但是却没有在函数当中定义了。 
\item 字段 varnames，这个就表示在本地定义使用的变量了，在函数 test\_co01 当中主要有三个变量 a, b, c 。 
\item 字段 filename，就是 python 文件的地址了。 
\item 字段 firstlineno 说明函数的第一行出现在对应 python 代码的 第 8 行。 
\end{itemize}
\subsubsection{Flags 字段详细分析}
我们具体使用 python3.5 的源代码进行分析，在 cpython 虚拟机的具体实现如下所示（Include/code.h）：
\begin{lstlisting}[style=cpp,caption=, language=C++]

/* Masks for co_flags above */
#define CO_OPTIMIZED	0x0001
#define CO_NEWLOCALS	0x0002
#define CO_VARARGS	0x0004
#define CO_VARKEYWORDS	0x0008
#define CO_NESTED       0x0010
#define CO_GENERATOR    0x0020
/* The CO_NOFREE flag is set if there are no free or cell variables.
   This information is redundant, but it allows a single flag test
   to determine whether there is any extra work to be done when the
   call frame it setup.
*/
#define CO_NOFREE       0x0040
/* The CO_COROUTINE flag is set for coroutine functions (defined with
   async def keywords) */
#define CO_COROUTINE            0x0080
#define CO_ITERABLE_COROUTINE   0x0100
\end{lstlisting}
如果 flags 字段和上面的各个宏定义进行 \& 运算，如果得到的结果大于 0，则说明符合对应的条件。
上面的宏定义的含义如下所示：
\begin{itemize}
\item CO\_OPTIMIZED，这个字段表示 code object 是被优化过的，使用函数本地定义的变量。 
\item CO\_NEWLOCALS，这个字段的含义为当这个 code object 的代码被执行的时候会给栈帧当中的 f\_locals 对象创建一个 dict 对象。 
\item CO\_VARARGS，表示这个 code object 对象是否含有位置参数。 
\item CO\_VARKEYWORDS，表示这个 code object 是否含有关键字参数。 
\item CO\_NESTED，表示这个 code object 是一个嵌套函数。 
\item CO\_GENERATOR，表示这个 code object 是一个生成器。 
\item CO\_COROUTINE，表示这个 code object 是一个协程函数。 
\item CO\_ITERABLE\_COROUTINE，表示 code object 是一个可迭代的协程函数。 
\item CO\_NOFREE，这个表示没有 freevars 和 cellvars，即没有函数闭包。 
\end{itemize}
现在再分析一下前面的函数 test\_co01 的 flags，他对应的值等于 0x43，则说明这个函数满足三个特性分别是 CO\_NEWLOCALS，CO\_OPTIMIZED 和 CO\_NOFREE。
\subsubsection{freevars \& cellvars}
我们使用下面的函数来对这两个字段进行分析：
\begin{lstlisting}[style=py,caption=, language=Python]

def test_co02():
    a = 1
    b = 2
    def g():
        return a + b
    return a + b + g()
\end{lstlisting}
上面的函数的信息如下所示（完整代码见[co02](https://github.com/Chang-LeHung/dive-into-cpython/blob/master/code/codeobject/co01.py)）：
\begin{lstlisting}[style=cpp,caption=, language=C++]

code
   argcount 0
   nlocals 1
   stacksize 3
   flags 0003 0x3
   code
      b'640100890000640200890100870000870100660200640300640400860000'
      b'7d0000880000880100177c00008300001753'
 15           0 LOAD_CONST               1 (1)
              3 STORE_DEREF              0 (a)
 16           6 LOAD_CONST               2 (2)
              9 STORE_DEREF              1 (b)
 18          12 LOAD_CLOSURE             0 (a)
             15 LOAD_CLOSURE             1 (b)
             18 BUILD_TUPLE              2
             21 LOAD_CONST               3 (<code object g at 0x7f133ff496f0, file "/tmp/pycharm_project_396/co01.py", line 18>)
             24 LOAD_CONST               4 ('test_co02.<locals>.g')
             27 MAKE_CLOSURE             0
             30 STORE_FAST               0 (g)
 20          33 LOAD_DEREF               0 (a)
             36 LOAD_DEREF               1 (b)
             39 BINARY_ADD
             40 LOAD_FAST                0 (g)
             43 CALL_FUNCTION            0 (0 positional, 0 keyword pair)
             46 BINARY_ADD
             47 RETURN_VALUE
   consts
      None
      1
      2
      code
         argcount 0
         nlocals 0
         stacksize 2
         flags 0013 0x13
         code b'8800008801001753'
 19           0 LOAD_DEREF               0 (a)
              3 LOAD_DEREF               1 (b)
              6 BINARY_ADD
              7 RETURN_VALUE
         consts
            None
         names ()
         varnames ()
         freevars ('a', 'b')
         cellvars ()
         filename '/tmp/pycharm_project_396/co01.py'
         name 'g'
         firstlineno 18
         lnotab b'0001'
      'test_co02.<locals>.g'
   names ()
   varnames ('g',)
   freevars ()
   cellvars ('a', 'b')
   filename '/tmp/pycharm_project_396/co01.py'
   name 'test_co02'
   firstlineno 14
   lnotab b'0001060106021502'
\end{lstlisting}
从上面的输出我们可以看到的是，函数 test\_co02 的 cellvars 为 ('a', 'b')，函数 g 的 freevars 为 ('a', 'b')，cellvars 表示在其他函数当中会使用本地定义的变量，freevars 表示本地会使用其他函数定义的变量。
再来分析一下函数 test\_co02 的 flags，他的 flags 等于 0x3 因为有闭包的存在因此 flags 不会存在 CO\_NOFREE，也就是少了值 0x0040 。
\subsubsection{stacksize}
这个字段存储的是在函数在被虚拟机执行的时候所需要的最大的栈空间的大小，这也是一种优化手段，因为在知道所需要的最大的栈空间，所以可以在函数执行的时候直接分配指定大小的空间不需要在函数执行的时候再去重新扩容。
\begin{lstlisting}[style=py,caption=, language=Python]

def test_stack():
    a = 1
    b = 2
    return a + b
\end{lstlisting}
上面的代码相关字节码等信息如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

code
   argcount 0
   nlocals 2
   stacksize 2
   flags 0043 0x43
   code b'6401007d00006402007d01007c00007c01001753'
   #					  字节码指令		 字节码指令参数  参数对应的值
 24           0 LOAD_CONST               1 (1)
              3 STORE_FAST               0 (a)
 25           6 LOAD_CONST               2 (2)
              9 STORE_FAST               1 (b)
 26          12 LOAD_FAST                0 (a)
             15 LOAD_FAST                1 (b)
             18 BINARY_ADD
             19 RETURN_VALUE
   consts
      None # 下标等于 0 的常量
      1 	# 下标等于 1 的常量
      2	   # 下标等于 2 的常量
   names ()
   varnames ('a', 'b')
   freevars ()
   cellvars ()
\end{lstlisting}
我们现在来模拟一下执行过程，在模拟之前我们首先来了解一下上面几条字节码的作用：
\begin{itemize}
\item LOAD\_CONST，将常量表当中的下标等于 i 个对象加载到栈当中，对应上面的代码  LOAD\_CONST 的参数 i = 1。因此加载测常量等于 1 。因此现在栈空间如下所示： 

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.2]{images/39-codeobject.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
\item STORE\_FAST，将栈顶元素弹出并且保存到 co\_varnames 对应的下标当中，根据上面的字节码参数等于 0 ，因此将 1 保存到 co\_varnames[0] 对应的对象当中。 

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.2]{images/40-codeobject.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
\item LOAD\_CONST，将下标等于 2 的常量加载进入栈中。 

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.2]{images/41-codeobject.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
\item STORE\_FAST，将栈顶元素弹出，并且保存到 varnames 下标为 1 的对象。 

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.2]{images/42-codeobject.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
\item LOAD\_FAST，是取出 co\_varnames 对应下标的数据，并且将其压入栈中。我们直接连续执行两个 LOAD\_FAST 之后栈空间的布局如下： 

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.2]{images/43-codeobject.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
\item BINARY\_ADD，这个字节码指令是将栈空间的两个栈顶元素弹出，然后将两个数据进行相加操作，然后将相加得到的结果重新压入栈中。 

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.2]{images/44-codeobject.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
\item RETURN\_VALUE，将栈顶元素弹出并且作为返回值返回。 
\end{itemize}
从上面的整个执行过程来看整个栈空间使用的最大的空间长度为 2 ，因此 stacksize = 2 。
\subsection{总结}
在本小节当中主要分析了一些 code obejct 当中比较重要的字段，code object 是 cpython 虚拟机当中一个比较重要的数据结构，深入的去理解这里面的字段对于我们理解 python 虚拟机非常有帮助。

\section{令人拍案叫绝的字节码设计}
在本小节当中主要给大家介绍 cpython 虚拟机对于字节码的设计以及在调试过程当中一个比较重要的字段 co\_lnotab 的设计原理！
\subsection{python 字节码设计}
一条 python 字节码主要有两部分组成，一部分是操作码，一部分是这个操作码的参数，在 cpython 当中只有部分字节码有参数，如果对应的字节码没有参数，那么 oparg 的值就等于 0 ，在 cpython 当中 opcode < 90 的指令是没有参数的。

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/45-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}

opcode 和 oparg 各占一个字节，cpython 虚拟机使用小端方式保存字节码。
我们使用下面的代码片段先了解一下字节码的设计：
\begin{lstlisting}[style=py,caption=, language=Python]

import dis
def add(a, b):
    return a + b
if __name__ == '__main__':
    print(add.__code__.co_code)
    print("bytecode: ", list(bytearray(add.__code__.co_code)))
    dis.dis(add)
\end{lstlisting}
上面的代码在 python3.9 的输出如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

b'|\x00|\x01\x17\x00S\x00'
bytecode:  [124, 0, 124, 1, 23, 0, 83, 0]
  5           0 LOAD_FAST                0 (a)
              2 LOAD_FAST                1 (b)
              4 BINARY_ADD
              6 RETURN_VALUE
\end{lstlisting}
首先 需要了解的是 \verb|add.__code__.co_code| 是函数 add 的字节码，是一个字节序列，\verb|list(bytearray(add.__code__.co_code))| 是将和这个序列一个字节一个字节进行分开，并且将其变成 10 进制形式。根据前面我们谈到的每一条指令——字节码占用 2 个字节，因此上面的字节码有四条指令：

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/46-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}

操作码和对应的操作指令在文末有详细的对应表。在上面的代码当中主要使用到了三个字节码指令分别是 124，23 和 83 ，他们对应的操作指令分别为 LOAD\_FAST，BINARY\_ADD，RETURN\_VALUE。他们的含义如下：
\begin{itemize}
\item LOAD\_FAST：将 varnames[var\_num] 压入栈顶。
\item BINARY\_ADD：从栈中弹出两个对象并且将它们相加的结果压入栈顶。
\item RETURN\_VALUE：弹出栈顶的元素，将其作为函数的返回值。
\end{itemize}
首先我们需要知道的是 BINARY\_ADD 和 RETURN\_VALUE，这两个操作指令是没有参数的，因此在这两个操作码之后的参数都是 0 。
但是 LOAD\_FAST 是有参数的，在上面我们已经知道 LOAD\_FAST 是将 co-varnames[var\_num] 压入栈，var\_num 就是指令 LOAD\_FAST 的参数。在上面的代码当中一共有两条 LOAD\_FAST 指令，分别是将 a 和 b 压入到栈中，他们在 varnames 当中的下标分别是 0 和 1，因此他们的操作数就是 0 和 1 。
\subsection{字节码扩展参数}
在上面我们谈到的 python 字节码操作数和操作码各占一个字节，但是如果 varnames 或者常量表的数据的个数大于 1 个字节的表示范围的话那么改如何处理呢？
为了解决这个问题，cpython 为字节码设计的扩展参数，比如说我们要加载常量表当中的下标为 66113 的对象，那么对应的字节码如下：
\begin{lstlisting}[style=py,caption=, language=Python]

[144, 1, 144, 2, 100, 65]
\end{lstlisting}
其中 144 表示 EXTENDED\_ARG，他本质上不是一个 python 虚拟机需要执行的字节码，这个字段设计出来主要是为了用与计算扩展参数的。
100 对应的操作指令是 LOAD\_CONST ，其操作码是 65，但是上面的指令并不会加载常量表当中下标为 65 对象，而是会加载下标为 66113 的对象，原因就是因为  EXTENDED\_ARG 。
现在来模拟一下上面的分析过程：
\begin{itemize}
\item 先读取一条字节码指令，操作码等于 144 ，说明是扩展参数，那么此时的参数 arg 就等于 (1 x (1 << 8)) = 256 。
\item 读取第二条字节码指令，操作码等于 144 ，说明是扩展参数，因为前面 arg 已经存在切不等于 0 了，那么此时 arg 的计算方式已经发生了改变，arg = arg << 8 + 2 << 8 ，也就是说原来的 arg 乘以 256 再加上新的操作数乘以 256 ，此时 arg = 66048 。
\item 读取第三条字节码指令，操作码等于 100，此时是 LOAD\_CONST 这条指令，那么此时的操作码等于 arg += 65，因为操作码不是 EXTENDED\_ARG 因此操作数不需要在乘以 256 了。
\end{itemize}
上面的计算过程用程序代码表示如下，下面的代码当中 code 就是真正的字节序列 HAVE\_ARGUMENT = 90 。
\begin{lstlisting}[style=py,caption=, language=Python]

def _unpack_opargs(code):
    extended_arg = 0
    for i in range(0, len(code), 2):
        op = code[i]
        if op >= HAVE_ARGUMENT:
            arg = code[i+1] | extended_arg
            extended_arg = (arg << 8) if op == EXTENDED_ARG else 0
        else:
            arg = None
        yield (i, op, arg)
\end{lstlisting}
我们可以使用代码来验证我们前面的分析：
\begin{lstlisting}[style=py,caption=, language=Python]

import dis
def num_to_byte(n):
    return n.to_bytes(1, "little")
def nums_to_bytes(data):
    ans = b"".join([num_to_byte(n) for n in data])
    return ans
if __name__ == '__main__':
    \section{extended_arg extended_num opcode oparg for python_version > 3.5}
    bytecode = nums_to_bytes([144, 1, 144, 2, 100, 65])
    print(bytecode)
    dis.dis(bytecode)
\end{lstlisting}
上面的代码输出结果如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

b'\x90\x01\x90\x02dA'
          0 EXTENDED_ARG             1
          2 EXTENDED_ARG           258
          4 LOAD_CONST           66113 (66113)
\end{lstlisting}
根据上面程序的输出结果可以看到我们的分析结果是正确的。
\subsection{源代码字节码映射表}
在本小节主要分析一个 code object 对象当中的 co\_lnotab 字段，通过分析一个具体的字段来学习这个字段的设计。
\begin{lstlisting}[style=py,caption=, language=Python]

import dis
def add(a, b):
    a += 1
    b += 2
    return a + b
if __name__ == '__main__':
    dis.dis(add.__code__)
    print(f"{list(bytearray(add.__code__.co_lnotab)) = }")
    print(f"{add.__code__.co_firstlineno = }")
\end{lstlisting}
首先 dis 的输出第一列是字节码对应的源代码的行号，第二列是字节码在字节序列当中的位移。
上面的代码输出结果如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

  源代码的行号  字节码的位移
  6           0 LOAD_FAST                0 (a)
              2 LOAD_CONST               1 (1)
              4 INPLACE_ADD
              6 STORE_FAST               0 (a)
  7           8 LOAD_FAST                1 (b)
             10 LOAD_CONST               2 (2)
             12 INPLACE_ADD
             14 STORE_FAST               1 (b)
  8          16 LOAD_FAST                0 (a)
             18 LOAD_FAST                1 (b)
             20 BINARY_ADD
             22 RETURN_VALUE
list(bytearray(add.__code__.co_lnotab)) = [0, 1, 8, 1, 8, 1]
add.__code__.co_firstlineno = 5
\end{lstlisting}
从上面代码的输出结果可以看出字节码一共分成三段，每段表示一行代码的字节码。现在我们来分析一下 co\_lnotab 这个字段，这个字段其实也是两个字节为一段的。比如上面的 [0, 1, 8, 1, 8, 1] 就可以分成三段 [0, 1], [8, 1], [8, 1] 。这其中的含义分别为：
\begin{itemize}
\item 第一个数字表示距离上一行代码的字节码数目。
\item 第二个数字表示距离上一行有效代码的行数。
\end{itemize}
现在我们来模拟上面代码的字节码的位移和源代码行数之间的关系：
\begin{itemize}
\item [0, 1]，说明这行代码离上一行代码的字节位移是 0 ，因此我们可以看到使用 dis 输出的字节码 LOAD\_FAST ，前面的数字是 0，距离上一行代码的行数等于 1 ，代码的第一行的行号等于 5，因此 LOAD\_FAST 对应的行号等于 5 + 1 = 6 。
\item [8, 1]，说明这行代码距离上一行代码的字节位移为 8 个字节，因此第二块的 LOAD\_FAST 前面是 8 ，距离上一行代码的行数等于 1，因此这个字节码对应的源代码的行号等于 6 + 1 = 7。
\item [8, 1]，同理可以知道这块字节码对应源代码的行号是 8 。
\end{itemize}
现在有一个问题是当两行代码之间相距的行数超过 一个字节的表示范围怎么办？在 python3.5 以后如果行数差距大于 127，那么就使用 (0, 行数) 对下一个组合进行表示，(0, $x\_1$), (0,$ x\_2$) ... ，直到 $x\_1 + ... + x\_n$ = 行数。
在后面的程序当中我们会使用 compile 这个 python 内嵌函数。当你使用Python编写代码时，可以使用\verb|compile()|函数将Python代码编译成字节代码对象。这个字节码对象可以被传递给Python的解释器或虚拟机，以执行代码。
\verb|compile()|函数接受三个参数：
\begin{itemize}
\item \verb|source|: 要编译的Python代码，可以是字符串，字节码或AST对象。
\item \verb|filename|: 代码来源的文件名（如果有），通常为字符串。
\item \verb|mode|: 编译代码的模式。可以是 'exec'、'eval' 或 'single' 中的一个。'exec' 模式用于编译多行代码，'eval' 用于编译单个表达式，'single' 用于编译单行代码。
\end{itemize}
\begin{lstlisting}[style=py,caption=, language=Python]

import dis
code = """
x=1
y=2
""" \
+ "\n" * 500 + \
"""
z=x+y
"""
code = compile(code, '<string>', 'exec')
print(list(bytearray(code.co_lnotab)))
print(code.co_firstlineno)
dis.dis(code)
\end{lstlisting}
上面的代码输出结果如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

[0, 1, 4, 1, 4, 127, 0, 127, 0, 127, 0, 121]
1
  2           0 LOAD_CONST               0 (1)
              2 STORE_NAME               0 (x)
  3           4 LOAD_CONST               1 (2)
              6 STORE_NAME               1 (y)
505           8 LOAD_NAME                0 (x)
             10 LOAD_NAME                1 (y)
             12 BINARY_ADD
             14 STORE_NAME               2 (z)
             16 LOAD_CONST               2 (None)
             18 RETURN_VALUE
\end{lstlisting}
根据我们前面的分析因为第三行和第二行之间的差距大于 127 ，因此后面的多个组合都是用于表示行数的。
505 = 3(前面已经有三行了) + (127 + 127 + 127 + 121)(这个是第二行和第三行之间的差距，这个值为 502，中间有 500 个换行但是因为字符串相加的原因还增加了两个换行，因此一共是 502 个换行)。
具体的算法用代码表示如下所示，下面的参数就是我们传递给 dis 模块的 code，也就是一个 code object 对象。
\begin{lstlisting}[style=py,caption=, language=Python]

def findlinestarts(code):
    """Find the offsets in a byte code which are start of lines in the source.
    Generate pairs (offset, lineno) as described in Python/compile.c.
    """
    byte_increments = code.co_lnotab[0::2]
    line_increments = code.co_lnotab[1::2]
    bytecode_len = len(code.co_code)
    lastlineno = None
    lineno = code.co_firstlineno
    addr = 0
    for byte_incr, line_incr in zip(byte_increments, line_increments):
        if byte_incr:
            if lineno != lastlineno:
                yield (addr, lineno)
                lastlineno = lineno
            addr += byte_incr
            if addr >= bytecode_len:
                # The rest of the lnotab byte offsets are past the end of
                # the bytecode, so the lines were optimized away.
                return
        if line_incr >= 0x80:
            # line_increments is an array of 8-bit signed integers
            line_incr -= 0x100
        lineno += line_incr
    if lineno != lastlineno:
        yield (addr, lineno)
\end{lstlisting}
\subsection{python 字节码表}
\begin{table}[H]
    \centering
    \caption{操作及操作码}
      \begin{tabular}{|l|l|l|l|}
      \hline
      操作    & 操作码 &操作    & 操作码\\
      \hline
      POP\_TOP & 1 &POP\_TOP & 1 \\ \hline
      ROT\_THREE & 3 &ROT\_THREE & 3 \\ \hline
      DUP\_TOP\_TWO & 5 &DUP\_TOP\_TWO & 5 \\ \hline
      NOP & 9 &NOP & 9 \\ \hline
      UNARY\_NEGATIVE & 11 &UNARY\_NEGATIVE & 11 \\ \hline
      UNARY\_INVERT & 15 &UNARY\_INVERT & 15 \\ \hline
      INPLACE\_MATRIX\_MULTIPLY & 17 &INPLACE\_MATRIX\_MULTIPLY & 17 \\ \hline
      BINARY\_MULTIPLY & 20 &BINARY\_MULTIPLY & 20 \\ \hline
      BINARY\_ADD & 23 &BINARY\_ADD & 23 \\ \hline
      BINARY\_SUBSCR & 25 &BINARY\_SUBSCR & 25 \\ \hline
      BINARY\_TRUE\_DIVIDE & 27 &BINARY\_TRUE\_DIVIDE & 27 \\ \hline
      INPLACE\_TRUE\_DIVIDE & 29 &INPLACE\_TRUE\_DIVIDE & 29 \\ \hline
      MATCH\_MAPPING & 31 &MATCH\_MAPPING & 31 \\ \hline
      MATCH\_KEYS & 33 &MATCH\_KEYS & 33 \\ \hline
      WITH\_EXCEPT\_START & 49 &WITH\_EXCEPT\_START & 49 \\ \hline
      GET\_ANEXT & 51 &GET\_ANEXT & 51 \\ \hline
      END\_ASYNC\_FOR & 54 &END\_ASYNC\_FOR & 54 \\ \hline
      INPLACE\_SUBTRACT & 56 &INPLACE\_SUBTRACT & 56 \\ \hline
      INPLACE\_MODULO & 59 &INPLACE\_MODULO & 59 \\ \hline
      DELETE\_SUBSCR & 61 &DELETE\_SUBSCR & 61 \\ \hline
      BINARY\_RSHIFT & 63 &BINARY\_RSHIFT & 63 \\ \hline
      BINARY\_XOR & 65 &BINARY\_XOR & 65 \\ \hline
      INPLACE\_POWER & 67 &INPLACE\_POWER & 67 \\ \hline
      GET\_YIELD\_FROM\_ITER & 69 &GET\_YIELD\_FROM\_ITER & 69 \\ \hline
      LOAD\_BUILD\_CLASS & 71 &LOAD\_BUILD\_CLASS & 71 \\ \hline
      GET\_AWAITABLE & 73 &GET\_AWAITABLE & 73 \\ \hline
      INPLACE\_LSHIFT & 75 &INPLACE\_LSHIFT & 75 \\ \hline
      INPLACE\_AND & 77 &INPLACE\_AND & 77 \\ \hline
      INPLACE\_OR & 79 &INPLACE\_OR & 79 \\ \hline
      RETURN\_VALUE & 83 &RETURN\_VALUE & 83 \\ \hline
      SETUP\_ANNOTATIONS & 85 &SETUP\_ANNOTATIONS & 85 \\ \hline
      POP\_BLOCK & 87 &POP\_BLOCK & 87 \\ \hline
      STORE\_NAME & 90 &STORE\_NAME & 90 \\ \hline
      \end{tabular}
\end{table}

\begin{table}[H]
    \ContinuedFloat
    \centering
    \caption{（续表）}\label{tab:longtable-continued}
      \begin{tabular}{|l|l|l|l|}
      \hline
      操作    & 操作码 &操作    & 操作码 \\
      \hline
      UNPACK\_SEQUENCE & 92 &UNPACK\_SEQUENCE & 92 \\ \hline
      UNPACK\_EX & 94 &UNPACK\_EX & 94 \\ \hline
      DELETE\_ATTR & 96 &DELETE\_ATTR & 96 \\ \hline
      DELETE\_GLOBAL & 98 &DELETE\_GLOBAL & 98 \\ \hline
      LOAD\_CONST & 100 &LOAD\_CONST & 100 \\ \hline
      BUILD\_TUPLE & 102 &BUILD\_TUPLE & 102 \\ \hline
      BUILD\_SET & 104 &BUILD\_SET & 104 \\ \hline
      LOAD\_ATTR & 106 &LOAD\_ATTR & 106 \\ \hline
      IMPORT\_NAME & 108 &IMPORT\_NAME & 108 \\ \hline
      JUMP\_FORWARD & 110 &JUMP\_FORWARD & 110 \\ \hline
      JUMP\_IF\_TRUE\_OR\_POP & 112 &JUMP\_IF\_TRUE\_OR\_POP & 112 \\ \hline
      POP\_JUMP\_IF\_FALSE & 114 &POP\_JUMP\_IF\_FALSE & 114 \\ \hline
      LOAD\_GLOBAL & 116 &LOAD\_GLOBAL & 116 \\ \hline
      CONTAINS\_OP & 118 &CONTAINS\_OP & 118 \\ \hline
      JUMP\_IF\_NOT\_EXC\_MATCH & 121 &JUMP\_IF\_NOT\_EXC\_MATCH & 121 \\ \hline
      LOAD\_FAST & 124 &LOAD\_FAST & 124 \\ \hline
      DELETE\_FAST & 126 &DELETE\_FAST & 126 \\ \hline
      RAISE\_VARARGS & 130 &RAISE\_VARARGS & 130 \\ \hline
      MAKE\_FUNCTION & 132 &MAKE\_FUNCTION & 132 \\ \hline
      LOAD\_CLOSURE & 135 &LOAD\_CLOSURE & 135 \\ \hline
      STORE\_DEREF & 137 &STORE\_DEREF & 137 \\ \hline
      CALL\_FUNCTION\_KW & 141 &CALL\_FUNCTION\_KW & 141 \\ \hline
      SETUP\_WITH & 143 &SETUP\_WITH & 143 \\ \hline
      LIST\_APPEND & 145 &LIST\_APPEND & 145 \\ \hline
      MAP\_ADD & 147 &MAP\_ADD & 147 \\ \hline
      MATCH\_CLASS & 152 &MATCH\_CLASS & 152 \\ \hline
      FORMAT\_VALUE & 155 &FORMAT\_VALUE & 155 \\ \hline
      BUILD\_STRING & 157 &BUILD\_STRING & 157 \\ \hline
      CALL\_METHOD & 161 &CALL\_METHOD & 161 \\ \hline
      SET\_UPDATE & 163 &SET\_UPDATE & 163 \\ \hline
      DICT\_UPDATE & 165 & & \\ \hline
        \end{tabular}
\end{table}
\subsection{总结}
在本小节当中主要给大家介绍了 cpython 当中对于字节码和源代码和字节码之间的映射关系的具体设计，这对于我们深入去理解 cpython 虚拟机的设计非常有帮助！

\section{字节码教程(1)——原来装饰器是这样实现的}
在本小节当中主要给大家介绍在 cpython 当中一些比较常见的字节码，从根本上理解 python 程序的执行。在本文当中主要介绍一些 python 基本操作的字节码，并且将从字节码的角度分析函数装饰器的原理！
\subsection{Python 常见字节码}
\subsubsection{LOAD\_CONST}
这个指令用于将一个常量加载到栈中。常量可以是数字、字符串、元组、列表、字典等对象。例如：
\begin{lstlisting}[style=py,caption=, language=Python]

>>> dis.dis(lambda: 42)
  1           0 LOAD_CONST               1 (42)
              2 RETURN_VALUE
\end{lstlisting}
\subsubsection{LOAD\_NAME}
这个指令用于将一个变量加载到栈中。例如：
\begin{lstlisting}[style=py,caption=, language=Python]

>>> dis.dis(lambda: x)
  1           0 LOAD_GLOBAL              0 (x)
              2 RETURN_VALUE
>>>
\end{lstlisting}
\subsubsection{STORE\_NAME}
这个指令用于将栈顶的值存储到一个变量中。例如：
\begin{lstlisting}[style=py,caption=, language=Python]

>>> dis.dis("x=42")
  1           0 LOAD_CONST               0 (42)
              2 STORE_NAME               0 (x)
              4 LOAD_CONST               1 (None)
              6 RETURN_VALUE
\end{lstlisting}
\subsubsection{BINARY\_ADD}
这个指令用于对栈顶的两个值进行加法运算并将结果推送到栈中。
\begin{lstlisting}[style=py,caption=, language=Python]

>>> dis.dis(lambda: x + y)
  1           0 LOAD_GLOBAL              0 (x)
              2 LOAD_GLOBAL              1 (y)
              4 BINARY_ADD
              6 RETURN_VALUE
\end{lstlisting}
\subsubsection{BINARY\_SUBTRACT}
这个指令用于对栈顶的两个值进行减法运算并将结果推送到栈中。
\begin{lstlisting}[style=py,caption=, language=Python]

>>> dis.dis(lambda: x _mmy) 
  1           0 LOAD_GLOBAL              0 (x)
              2 LOAD_GLOBAL              1 (y)
              4 BINARY_SUBTRACT
              6 RETURN_VALUE
\end{lstlisting}
同样的加减乘除取余数的字节码如下所示：
\begin{lstlisting}[style=py,caption=, language=Python]

>>> dis.dis(lambda: x + y)
  1           0 LOAD_GLOBAL              0 (x)
              2 LOAD_GLOBAL              1 (y)
              4 BINARY_ADD
              6 RETURN_VALUE
>>> dis.dis(lambda: x _mmy) 
  1           0 LOAD_GLOBAL              0 (x)
              2 LOAD_GLOBAL              1 (y)
              4 BINARY_SUBTRACT
              6 RETURN_VALUE
>>> dis.dis(lambda: x * y)
  1           0 LOAD_GLOBAL              0 (x)
              2 LOAD_GLOBAL              1 (y)
              4 BINARY_MULTIPLY
              6 RETURN_VALUE
>>> dis.dis(lambda: x / y)
  1           0 LOAD_GLOBAL              0 (x)
              2 LOAD_GLOBAL              1 (y)
              4 BINARY_TRUE_DIVIDE
              6 RETURN_VALUE
>>> dis.dis(lambda: x // y)
  1           0 LOAD_GLOBAL              0 (x)
              2 LOAD_GLOBAL              1 (y)
              4 BINARY_FLOOR_DIVIDE
              6 RETURN_VALUE
>>> dis.dis(lambda: x % y)
  1           0 LOAD_GLOBAL              0 (x)
              2 LOAD_GLOBAL              1 (y)
              4 BINARY_MODULO
              6 RETURN_VALUE
\end{lstlisting}
\subsubsection{COMPARE\_OP}
这个指令用于比较栈顶的两个值，并且将比较得到的结果压入栈中，这个字节码后面后一个字节的参数，表示小于大于不等于等等比较符号。例如：
\begin{lstlisting}[style=py,caption=, language=Python]

>>> dis.dis(lambda: x _mmy) 
  1           0 LOAD_GLOBAL              0 (x)
              2 LOAD_GLOBAL              1 (y)
              4 BINARY_SUBTRACT
              6 RETURN_VALUE
>>> dis.dis(lambda: x > y)
  1           0 LOAD_GLOBAL              0 (x)
              2 LOAD_GLOBAL              1 (y)
              4 COMPARE_OP               4 (>)
              6 RETURN_VALUE
>>> dis.dis(lambda: x < y)
  1           0 LOAD_GLOBAL              0 (x)
              2 LOAD_GLOBAL              1 (y)
              4 COMPARE_OP               0 (<)
              6 RETURN_VALUE
>>> dis.dis(lambda: x != y)
  1           0 LOAD_GLOBAL              0 (x)
              2 LOAD_GLOBAL              1 (y)
              4 COMPARE_OP               3 (!=)
              6 RETURN_VALUE
>>> dis.dis(lambda: x <= y)
  1           0 LOAD_GLOBAL              0 (x)
              2 LOAD_GLOBAL              1 (y)
              4 COMPARE_OP               1 (<=)
              6 RETURN_VALUE
>>> dis.dis(lambda: x >= y)
  1           0 LOAD_GLOBAL              0 (x)
              2 LOAD_GLOBAL              1 (y)
              4 COMPARE_OP               5 (>=)
              6 RETURN_VALUE
>>> dis.dis(lambda: x == y)
  1           0 LOAD_GLOBAL              0 (x)
              2 LOAD_GLOBAL              1 (y)
              4 COMPARE_OP               2 (==)
              6 RETURN_VALUE
\end{lstlisting}
\subsubsection{RETURN\_VALUE}
将栈顶元素弹出作为返回值。
\subsubsection{BUILD\_LIST}
这个指令用于创建一个列表。例如：
\begin{lstlisting}[style=py,caption=, language=Python]

>>> dis.dis(lambda: [a, b, c, e])
  1           0 LOAD_GLOBAL              0 (a)
              2 LOAD_GLOBAL              1 (b)
              4 LOAD_GLOBAL              2 (c)
              6 LOAD_GLOBAL              3 (e)
              8 BUILD_LIST               4
             10 RETURN_VALUE
\end{lstlisting}
这条字节码指令有一个参数表示栈空间当中列表元素的个数，在上面的例子当中这个参数是 4 。
\subsubsection{BUILD\_TUPLE}
这个指令用于创建一个元组。例如：
\begin{lstlisting}[style=py,caption=, language=Python]

>>> dis.dis(lambda: (a, b, c))
  1           0 LOAD_GLOBAL              0 (a)
              2 LOAD_GLOBAL              1 (b)
              4 LOAD_GLOBAL              2 (c)
              6 BUILD_TUPLE              3
              8 RETURN_VALUE
\end{lstlisting}
同样的这个字节码也有一个参数，表示创建元组的元素个数。
\subsubsection{BUILD\_MAP}
这个指令用于创建一个字典。例如：
\begin{lstlisting}[style=py,caption=, language=Python]

\end{lstlisting}
\subsubsection{BUILD\_SET}
和 list 和 tuple 一样，这条指令是用于创建一个集合对象，同样的这条指令也有一个参数表示用于创建集合的元素的个数。
\begin{lstlisting}[style=py,caption=, language=Python]

>>> dis.dis(lambda: {a, b, c, d})
  1           0 LOAD_GLOBAL              0 (a)
              2 LOAD_GLOBAL              1 (b)
              4 LOAD_GLOBAL              2 (c)
              6 LOAD_GLOBAL              3 (d)
              8 BUILD_SET                4
             10 RETURN_VALUE
\end{lstlisting}
\subsubsection{BUILD\_CONST\_KEY\_MAP}
这条指令是用于创建一个字典对象，同样的这条指令也有一个参数，表示字典当中元素的个数。
\begin{lstlisting}[style=py,caption=, language=Python]

>>> dis.dis(lambda: {1:2, 3:4})
  1           0 LOAD_CONST               1 (2)
              2 LOAD_CONST               2 (4)
              4 LOAD_CONST               3 ((1, 3))
              6 BUILD_CONST_KEY_MAP      2
              8 RETURN_VALUE
\end{lstlisting}
\subsection{从字节码角度分析装饰器的原理}
如果你是一个 pythoner 那么你肯定或多或少听说过装饰器，这是一个 python 的语法糖我们可以用它来做很多有趣的事情，比如在不修改源代码的基础之上给函数附加一些功能，比如说计算时间。
\begin{lstlisting}[style=py,caption=, language=Python]

import time
def eval_time(func):
    
    def cal_time(*args, kwargs):
        start = time.time()
        r = func(*args, kwargs)
        end = time.time()
        return r, end _mmstart 
    return cal_time
@eval_time
def fib(n):
    a = 0
    b = 1
    while n > 0:
        n -= 1
        a, b = b, a + b
    return a
\end{lstlisting}
在上面的代码当中我们实现了一个计算斐波拉契数列的函数，除此之外还写了一个 eval\_time 函数用于计算函数执行的时间，现在调用函数 fib(10)，程序的输出如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

>>>fib(10)
(55, 5.9604644775390625e-06)
\end{lstlisting}
可以看到实现了我们想要的效果。
现在我们使用一个更加简单的例子来模拟上面的代码结构，方便我们对上面函数执行的过程进行分析：
\begin{lstlisting}[style=py,caption=, language=Python]

s = """
def decorator(func):
    print("Hello")
    return func
@decorator
def fib(n):
    pass
"""
dis.dis(s)
\end{lstlisting}
上面的 dis 函数的输出对应代码的字节码如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

  2           0 LOAD_CONST               0 (<code object decorator at 0x108068d40, file "<dis>", line 2>)
              2 LOAD_CONST               1 ('decorator')
              4 MAKE_FUNCTION            0
              6 STORE_NAME               0 (decorator)
  6           8 LOAD_NAME                0 (decorator)
  7          10 LOAD_CONST               2 (<code object fib at 0x1075c1710, file "<dis>", line 6>)
             12 LOAD_CONST               3 ('fib')
             14 MAKE_FUNCTION            0
             16 CALL_FUNCTION            1
             18 STORE_NAME               1 (fib)
             20 LOAD_CONST               4 (None)
             22 RETURN_VALUE
Disassembly of <code object decorator at 0x108068d40, file "<dis>", line 2>:
  3           0 LOAD_GLOBAL              0 (print)
              2 LOAD_CONST               1 ('Hello')
              4 CALL_FUNCTION            1
              6 POP_TOP
  4           8 LOAD_FAST                0 (func)
             10 RETURN_VALUE
Disassembly of <code object fib at 0x1075c1710, file "<dis>", line 6>:
  8           0 LOAD_CONST               0 (None)
              2 RETURN_VALUE
\end{lstlisting}
\begin{itemize}
\item 执行第一条指令 LOAD\_CONST，这条指令主要是加载一个 code object 对象，这个对象里面主要是包含函数 decorator 的字节码，主要是上面字节码的第二块内容。在执行完这条字节码之后栈空间如下所示： 

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/47-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
\item 执行完第二条指令 LOAD\_CONST 之后，会将字符串 decorator 加载进入栈空间当中。 

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/48-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
\item 执行第三条指令 MAKE\_FUNCTION，这条字节码的作用是在虚拟机内部创建一个函数，函数的名称为 decorator，函数对应的字节码则是在先前压入栈空间当中的 code object 对象，这条指令还会将创建好的函数对象压入栈中。 

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/49-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
\item STORE\_NAME，条字节码会将栈顶的元素弹出，并且将 co\_names[oparg]  指向这个对象，在上面的字节码当中 co\_names[oparg]  就是 decorator 。 

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/50-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
\item LOAD\_NAME，这条字节码就是将 co\_names[oparg] 对应的名字指向的对象重新加载进入栈空间当中，也就是上面的 decorator 函数加入进行栈空间当中。 

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/51-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
\item 接下来的三条字节码 LOAD\_CONST，LOAD\_CONST 和 MAKE\_FUNCTION，在执行这三条字节码之后，栈空间如下所示： 

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/52-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
\item 接下来的一条指令非常重要，这条指令便是装饰器的核心原理，CALL\_FUNCTION 这条指令有一个参数 i，在上面的字节码当中为 1，也就是说从栈顶开始的前 i 个元素都是函数参数，调用的函数在栈空间的位置为 i + 1 （从栈顶往下数），那么在上面的情况下就是说调用 decorator 函数，并且将 fib 函数作为 decorator 函数的参数，decorator 函数的返回值再压入栈顶。在上面的代码当中 decorator 函数返回值也是一个函数，也就是 decorator 函数的参数，即 fib 函数。 

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/54-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
\item 接下来便是 STORE\_NAME 字节码，这条字节码的含义我们在前面已经说过了，就是将栈顶元素弹出，保存到 co\_names[oparg] 指向的对象当中，在上面的代码当中也就是将栈顶的对象保存到 fib 当中。栈顶元素 fib 函数是调用函数 decorator 的返回值。 
\end{itemize}
看到这里就能够理解了原来装饰器的最根本的原理不就是函数调用嘛，比如我们最前面的用于计算函数执行时间的装饰器的原理就是：
\begin{lstlisting}[style=py,caption=, language=Python]
fib = eval_time(fib)
\end{lstlisting}
将 fib 函数作为 eval\_time 函数的参数，再将这个函数的返回值保存到 fib 当中，当然这个对象必须是可调用的，不然后面使用 fib() 就会保存，我们可以使用下面的代码来验证这个效果。
\begin{lstlisting}[style=py,caption=, language=Python]

def decorator(func):
    return func()
@decorator
def demo():
    return "function demo return string : Demo"
print(demo)
\end{lstlisting}
执行上面的程序结果为：
\begin{lstlisting}[style=cpp,caption=, language=C++]

function demo return string : Demo
\end{lstlisting}
可以看到 demo 已经变成了一个字符串对象而不再是一个函数了，因为 \verb|demo = decorator(demo)|，而在函数 decorator 当中返回值是 demo 函数自己的返回值，因此才打印了字符串。
\subsection{总结}
在本小节当中主要给大家介绍了 python 当中一些基础的字节码对应的含义以及示例代码，本小节最重要的便是从字节码的角度解释了装饰器的本质原理，这对我们以后使用装饰器非常有帮助，可以灵活的控制和了解装饰器其中发生的故事。


\section{字节码教程(2)——控制流是如何实现的？}
在本小节当中主要给大家分析 python 当中与控制流有关的字节码，通过对这部分字节码的了解，我们可以更加深入了解 python 字节码的执行过程和控制流实现原理。
\subsection{控制流实现}
控制流这部分代码主要涉及下面几条字节码指令，下面的所有字节码指令都会有一个参数：
\begin{itemize}
\item JUMP\_FORWARD，指令完整条指令会将当前执行字节码指令的位置加上这个参数，然后跳到对应的结果继续执行。 
\item POP\_JUMP\_IF\_TRUE，如果栈顶元素等于 true，将字节码的执行位置改成参数的值。将栈顶元素弹出。 
\item POP\_JUMP\_IF\_FALSE，这条指令和 POP\_JUMP\_IF\_TRUE 一样，唯一差别就是判断栈顶元素是否等于 true。  
\item JUMP\_IF\_TRUE\_OR\_POP，如果栈顶元素等于等于 true 则将字节码执行位置设置成参数对应的值，并且不需要将栈顶元素弹出。但是如果栈顶元素是 false 的话那么就需要将栈顶元素弹出。 
\item JUMP\_IF\_FALSE\_OR\_POP，和JUMP\_IF\_TRUE\_OR\_POP一样只不过需要栈顶元素等于 false 。 
\item JUMP\_ABSOLUTE，直接将字节码的执行位置设置成参数的值。 
\end{itemize}
总的来说，这些跳转指令可以让 Python 的解释器在执行字节码时根据特定条件来改变执行流程，实现循环、条件语句等基本语言结构。
现在我们使用一个例子来深入理解上面的各种指令的执行过程。
\begin{lstlisting}[style=py,caption=, language=Python]

import dis
def test_control01():
    a = 1
    if a > 1:
        print("a > 1")
    elif a < 1:
        print("a < 1")
    else:
        print("a == 1")
if __name__ == '__main__':
    dis.dis(test_control01)
\end{lstlisting}
上面的程序输出结果如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

  6           0 LOAD_CONST               1 (1)
              2 STORE_FAST               0 (a)
  8           4 LOAD_FAST                0 (a)
              6 LOAD_CONST               1 (1)
              8 COMPARE_OP               4 (>)
             10 POP_JUMP_IF_FALSE       22
  9          12 LOAD_GLOBAL              0 (print)
             14 LOAD_CONST               2 ('a > 1')
             16 CALL_FUNCTION            1
             18 POP_TOP
             20 JUMP_FORWARD            26 (to 48)
 10     >>   22 LOAD_FAST                0 (a)
             24 LOAD_CONST               1 (1)
             26 COMPARE_OP               0 (<)
             28 POP_JUMP_IF_FALSE       40
 11          30 LOAD_GLOBAL              0 (print)
             32 LOAD_CONST               3 ('a < 1')
             34 CALL_FUNCTION            1
             36 POP_TOP
             38 JUMP_FORWARD             8 (to 48)
 13     >>   40 LOAD_GLOBAL              0 (print)
             42 LOAD_CONST               4 ('a == 1')
             44 CALL_FUNCTION            1
             46 POP_TOP
        >>   48 LOAD_CONST               0 (None)
             50 RETURN_VALUE
\end{lstlisting}
我们现在来模拟一下上面的字节码执行过程，我们使用 counter 表示当前字节码的执行位置：
在字节码还没开始执行之前，栈空间和 counter 的状态如下：

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/56-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
现在执行第一条字节码 LOAD\_CONST，执行完之后 counter = 2，因为这条字节码占一个字节，参数栈一个字节，因此下次执行的字节码的位置在 bytecode 的低三个位置，对应的下标为 2，因此 counter = 2 。

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/57-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
现在执行第二条字节码 STORE\_FAST，让 a 指向 1 ，同样的 STORE\_FAST 操作码和操作数各占一个字节，因此执行完这条字节码之后栈空间没有数据，counter = 4 。

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/58-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
接下来 LOAD\_FAST 将 a 指向的对象也就是 1 加载进入栈中，此时的 counter = 6，LOAD\_CONST 将常量 1 加载进行入栈空间当中，此时 counter = 8，在执行完这两条指令之后，栈空间的变化如下图所示：

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/59-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
接下来的一条指令是 COMPARE\_OP ，这个指令有一个参数表示比较的符号，这里是比较 a > 1，并且会将比较的结果压入栈中，比较的结果是 false ，因为 COMPARE\_OP 首先会将栈空间的两个输入弹出，因此在执行完这条指令之后栈空间和 counter 的值如下：

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/60-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
下面一条指令为 POP\_JUMP\_IF\_FALSE，根据前面的字节码含义，这个字节码会将栈顶的 false 弹出，并且会进行跳转，并且将 counter 的值直接编程参数的值，这里他的参数是 22 ，因此 counter = 22，在执行完这条指令之后，结果如下：

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/61-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
因为现在已经跳转到了 22 ，因此接下来执行的指令为 LOAD\_FAST，将变量 a 加载进入栈空间，LOAD\_CONST 将常量 1 加载进入栈空间，在执行完这两条执行之后，变化情况如下：

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/62-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
在次执行 POP\_JUMP\_IF\_FALSE，这回的结果也是 false ，因此继续执行 POP\_JUMP\_IF\_FALSE，这次的参数是 40，直接将 counter 的值设置成 40 。

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/63-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
接下来 LOAD\_GLOBAL 加载一个全局变量 print 函数 counter 变成 42 ，LOAD\_CONST 加载字符串 "a == 1" 进入栈空间，counter = 44，此时状态如下：

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/64-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
CALL\_FUNCTION 这个字节码有一个参数，表示调用函数的参数的个数，这里是 1，因为 print 函数只有一个参数，然后输出字符串 "a== 1"，但是这里需要注意的是 print 函数会返回一个 None，因此执行完 CALL\_FUNCTION 之后状态如下：

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/65-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
至此差不多上面的函数差不多执行完了，后面几条字节码很简单，就不再进行叙述了。
\subsection{总结}
在 Python 中，控制流指令可以让解释器根据特定条件改变执行流程，实现循环、条件语句等基本语言结构。Python 中与控制流有关的字节码指令包括 JUMP\_FORWARD、POP\_JUMP\_IF\_TRUE、POP\_JUMP\_IF\_FALSE、JUMP\_IF\_TRUE\_OR\_POP、JUMP\_IF\_FALSE\_OR\_POP 和 JUMP\_ABSOLUTE 等。这些指令都有一个参数，主要是用来计算跳转的目标位置等。通过对这些指令的了解，我们可以更深入地理解 Python 字节码的执行过程和控制流实现原理。


\section{字节码教程(3)——深入剖析循环实现原理}
在本小节当中主要给大家介绍 cpython 当中跟循环相关的字节码，这部分字节码相比起其他字节码来说相对复杂一点，通过分析这部分字节码我们对程序的执行过程将会有更加深刻的理解。
\subsection{循环}
\subsubsection{普通 for 循环实现原理}
我们使用各种例子来理解和循环相关的字节码：
\begin{lstlisting}[style=py,caption=, language=Python]

def test_loop():
    for i in range(10):
        print(i)
\end{lstlisting}
上面的代码对应的字节码如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

  8           0 LOAD_GLOBAL              0 (range)
              2 LOAD_CONST               1 (10)
              4 CALL_FUNCTION            1
              6 GET_ITER
        >>    8 FOR_ITER                12 (to 22)
             10 STORE_FAST               0 (i)
  9          12 LOAD_GLOBAL              1 (print)
             14 LOAD_FAST                0 (i)
             16 CALL_FUNCTION            1
             18 POP_TOP
             20 JUMP_ABSOLUTE            8
        >>   22 LOAD_CONST               0 (None)
             24 RETURN_VALUE
\end{lstlisting}
首先是 range 他对应一个 builtin 的类型，在执行上面的字节码的过程当中，首先先将 range 将在进入栈空间当中，然后将常量 10 加载进入栈空间当中，最后会调用指令 CALL\_FUNCTION，这个时候会将栈顶的两个元素弹出，调用 range 类型的创建函数，这个函数会返回一个 range 的实例对象。
这个时候栈的结果如下所示：

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/66-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
接下来的一条字节码为 GET\_ITER，这条字节码的含义为，弹出栈顶的对象，并且将弹出的对象变成一个迭代器，并且将得到的迭代器对象再压入栈空间当中。

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/67-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
接下来的一条指令是 FOR\_ITER，这条指令的含义为：已知栈顶对象是一个迭代器，调用这个迭代器的 \verb|__next__| 函数 ：
\begin{itemize}
\item 如果迭代器已经迭代完成了，则将栈顶的迭代器弹出，并且将 bytecode 的 counter 加上对应的参数值，在上面的函数字节码当中这个参数值等于 12 ，也就是说下一条指令为字节码序列的 22 这个位置。 
\item 如果没有迭代完成则将函数的返回值压入栈顶，并且不需要弹出迭代器，比如当我们第一次调用 \verb|__next__| 函数的时候，range 的返回值为0，那么此时栈空间的内容如下所示： 

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/68-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
\end{itemize}
接下来执行的字节码为 STORE\_FAST，这条字节码的含义就是弹出栈顶的元素，并且将这个元素保存到 co\_varnames[var\_num] 当中，var\_num 就是这条字节码的参数，在上面的函数当中就是 0，对应的变量为 i ，因此这条字节码的含义就是弹出栈顶的元素并且保存到变量 i 当中。
LOAD\_GLOBAL，将内嵌函数 print 加载进入栈中，LOAD\_FAST 将变量 i 加载进入栈空间当中，此时栈空间的内容如下所示：

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/69-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
CALL\_FUNCTION 会调用 print 函数打印数字 0，并且将函数的返回值压入栈空间当中，print 函数的返回值为 None，此时栈空间的内容如下所示：

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/70-bytecode.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
POP\_TOP 将栈顶的元素弹出，JUMP\_ABSOLUTE 字节码有一个参数，在上面的函数当中这个参数为 8 ，当执行这条字节码的时候直接将 bytecode 的 counter 直接设置成这个参数值，因此执行完这条字节码之后下一条被执行的字节码又是 FOR\_ITER，这便实现了循环的效果。
综合分析上面的分析过程，实现循环的效果主要是有两个字节码实现的，一个是 FOR\_ITER，当迭代器迭代完成之后，会直接跳出循环，实现这个的原理是在字节码的 counter 上加上一个值，另外一个就是 JUMP\_ABSOLUTE，他可以直接跳到某一处的字节码位置进行执行。
\subsubsection{continue 关键字实现原理}
\begin{lstlisting}[style=py,caption=, language=Python]

def test_continue():
    for i in range(10):
        data = random.randint(0, 10)
        if data < 5:
            continue
        print(f"{data = }")
\end{lstlisting}
其实通过对上面的字节码的分析之后，我们可以大致分析出 continue 的实现原理，首先我们知道 continue 的语意直接进行下一次循环，这个语意其实和循环体执行完之后的语意是一样的，在上一份代码的分析当中实现这个语意的字节码是 JUMP\_ABSOLUTE，直接跳到 FOR\_ITER 指令的位置继续开始执行。我们现在来看看上面的函数对应的字节码是什么：
\begin{lstlisting}[style=cpp,caption=, language=C++]

 13           0 LOAD_GLOBAL              0 (range)
              2 LOAD_CONST               1 (10)
              4 CALL_FUNCTION            1
              6 GET_ITER
        >>    8 FOR_ITER                40 (to 50)
             10 STORE_FAST               0 (i)
 14          12 LOAD_GLOBAL              1 (random)
             14 LOAD_METHOD              2 (randint)
             16 LOAD_CONST               2 (0)
             18 LOAD_CONST               1 (10)
             20 CALL_METHOD              2
             22 STORE_FAST               1 (data)
 15          24 LOAD_FAST                1 (data)
             26 LOAD_CONST               3 (5)
             28 COMPARE_OP               0 (<)
             30 POP_JUMP_IF_FALSE       34
 16          32 JUMP_ABSOLUTE            8
 17     >>   34 LOAD_GLOBAL              3 (print)
             36 LOAD_CONST               4 ('data = ')
             38 LOAD_FAST                1 (data)
             40 FORMAT_VALUE             2 (repr)
             42 BUILD_STRING             2
             44 CALL_FUNCTION            1
             46 POP_TOP
             48 JUMP_ABSOLUTE            8
        >>   50 LOAD_CONST               0 (None)
             52 RETURN_VALUE
\end{lstlisting}
\begin{itemize}
\item LOAD\_GLOBAL 0 (range): 加载全局变量 range，将其压入栈顶。 
\item LOAD\_CONST 1 (10): 加载常量值 10，将其压入栈顶。 
\item CALL\_FUNCTION 1: 调用栈顶的函数，此处为 range 函数，并传入一个参数，参数个数为 1。 
\item GET\_ITER: 获取迭代器对象。 
\item FOR\_ITER 40 (to 50): 迭代循环的开始，当迭代完成之后将字节码的 counter 加上 40 ，也就是跳转到 50 的位置执行。 
\item STORE\_FAST 0 (i): 将迭代器的值存储到局部变量 i 中。 
\item LOAD\_GLOBAL 1 (random): 加载全局变量 random，将其压入栈顶。 
\item LOAD\_METHOD 2 (randint): 加载对象 random 的属性 randint，将其压入栈顶。 
\item LOAD\_CONST 2 (0): 加载常量值 0，将其压入栈顶。 
\item LOAD\_CONST 1 (10): 加载常量值 10，将其压入栈顶。 
\item CALL\_METHOD 2: 调用栈顶的方法，此处为 random.randint 方法，并传入两个参数，参数个数为 2。 
\item STORE\_FAST 1 (data): 将方法返回值存储到局部变量 data 中。 
\item LOAD\_FAST 1 (data): 加载局部变量 data，将其压入栈顶。 
\item LOAD\_CONST 3 (5): 加载常量值 5，将其压入栈顶。 
\item COMPARE\_OP 0 (<): 执行比较操作 <，将结果压入栈顶。 
\item POP\_JUMP\_IF\_FALSE 34: 如果栈顶的比较结果为假，则跳转到字节码偏移为 34 的位置。 
\item JUMP\_ABSOLUTE 8: 无条件跳转到字节码偏移为 8 的位置，即循环的下一次迭代。 
\item LOAD\_GLOBAL 3 (print): 加载全局变量 print，将其压入栈顶。 
\item LOAD\_CONST 4 ('data = '): 加载常量字符串 'data = '，将其压入栈顶。 
\item LOAD\_FAST 1 (data): 加载局部变量 data，将其压入栈顶。 
\item FORMAT\_VALUE 2 (repr): 格式化栈顶的值，并指定格式化方式为 repr。 
\item BUILD\_STRING 2: 构建字符串对象，包含两个格式化后的值。 
\item CALL\_FUNCTION 1: 调用栈顶的函数，此处为 print 函数，并传入一个参数，参数个数为 1。 
\item POP\_TOP: 弹出栈顶的值，也就是函数 print 的返回值，print 函数返回值为 None 。 
\item JUMP\_ABSOLUTE 8: 无条件跳转到字节码偏移为 8 的位置，即循环的下一次迭代。 
\item LOAD\_CONST 0 (None): 加载常量值 None，将其压入栈顶。 
\item RETURN\_VALUE: 返回栈顶的值，即 None。 
\end{itemize}
这段字节码实现了一个简单的循环，使用 range 函数生成一个迭代器，然后对迭代器进行遍历，每次遍历都会调用 random.randint 方法生成一个随机数并存储到局部变量 data 中，然后根据 data 的值进行条件判断，如果小于 5 则打印 "data = " 和 data 的值，否则继续下一次循环，直到迭代器结束。最后返回 None。
\subsubsection{break 关键字实现原理}
\begin{lstlisting}[style=py,caption=, language=Python]

def test_break():
    for i in range(10):
        data = random.randint(0, 10)
        if data < 5:
            break
    return "BREAK"
\end{lstlisting}
上面的函数对应的字节码如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

 21           0 LOAD_GLOBAL              0 (range)
              2 LOAD_CONST               1 (10)
              4 CALL_FUNCTION            1
              6 GET_ITER
        >>    8 FOR_ITER                28 (to 38)
             10 STORE_FAST               0 (i)
 22          12 LOAD_GLOBAL              1 (random)
             14 LOAD_METHOD              2 (randint)
             16 LOAD_CONST               2 (0)
             18 LOAD_CONST               1 (10)
             20 CALL_METHOD              2
             22 STORE_FAST               1 (data)
 23          24 LOAD_FAST                1 (data)
             26 LOAD_CONST               3 (5)
             28 COMPARE_OP               0 (<)
             30 POP_JUMP_IF_FALSE        8
 24          32 POP_TOP
             34 JUMP_ABSOLUTE           38
             36 JUMP_ABSOLUTE            8
 26     >>   38 LOAD_CONST               4 ('BREAK')
             40 RETURN_VALUE
\end{lstlisting}
这段字节码与之前的字节码相似，但有一些细微的不同。
\begin{itemize}
\item LOAD\_GLOBAL 0 (range): 加载全局变量 range，将其压入栈顶。 
\item LOAD\_CONST 1 (10): 加载常量值 10，将其压入栈顶。 
\item CALL\_FUNCTION 1: 调用函数，函数参数个数为 1。 
\item GET\_ITER: 从栈顶获取可迭代对象，并返回迭代器对象。 
\item FOR\_ITER 28 (to 38): 遍历迭代器，如果迭代器为空，则跳转到字节码偏移为 38 的位置，即跳出循环，否则继续执行下一条字节码。 
\item STORE\_FAST 0 (i): 将迭代器的当前值存储到局部变量 i 中。 
\end{itemize}
接下来的字节码与之前的字节码相似，都是调用 random.randint 方法生成随机数，并将随机数存储到局部变量 data 中。然后，对局部变量 data 进行条件判断，如果小于 5 则跳出循环，否则继续下一次循环。不同的是，这里使用了 POP\_TOP 操作来弹出栈顶的值，即格式化后的字符串，无需使用。
\begin{itemize}
\item POP\_JUMP\_IF\_FALSE 8: 如果栈顶的值（即 data）不满足条件（小于 5），则跳转到字节码偏移为 8 的位置，即循环的下一次迭代。 
\item POP\_TOP: 弹出栈顶的值，也就是将迭代器弹出。 
\item JUMP\_ABSOLUTE 38: 无条件跳转到字节码偏移为 38 的位置，即跳出循环。 
\item JUMP\_ABSOLUTE 8: 无条件跳转到字节码偏移为 8 的位置，即循环的下一次迭代。 
\end{itemize}
最后，字节码加载了一个常量字符串 'BREAK'，并通过 RETURN\_VALUE 操作将其作为返回值返回。这段字节码实现了类似于之前的循环，但在满足条件时使用了 POP\_TOP 和跳转指令来优化循环的执行。
从上面的分析过程可以看出来 break 的实现也是通过 JUMP\_ABSOLUTE 来做到的，直接跳转到循环外部的下一行代码。
\subsection{总结}
在本本小节当中主要给大家分析了在python当中也循环有关的字节码，实现循环操作的主要是几个核心的字节码 FOR\_ITER ，JUMP\_ABSOLUTE，GET\_ITER 等等。只要深入了解了这几个字节码的功能理解循环的过程就很简单了。


\section{深入理解python虚拟机：程序执行的载体——栈帧}
栈帧（Stack Frame）是 Python 虚拟机中程序执行的载体之一，也是 Python 中的一种执行上下文。每当 Python 执行一个函数或方法时，都会创建一个栈帧来表示当前的函数调用，并将其压入一个称为调用栈（Call Stack）的数据结构中。调用栈是一个后进先出（LIFO）的数据结构，用于管理程序中的函数调用关系。
栈帧的创建和销毁是动态的，随着函数的调用和返回而不断发生。当一个函数被调用时，一个新的栈帧会被创建并推入调用栈，当函数调用结束后，对应的栈帧会从调用栈中弹出并销毁。
栈帧的使用使得 Python 能够实现函数的嵌套调用和递归调用。通过不断地创建和销毁栈帧，Python 能够跟踪函数调用关系，保存和恢复局部变量的值，实现函数的嵌套和递归执行。同时，栈帧还可以用于实现异常处理、调试信息的收集和优化技术等。
需要注意的是，栈帧是有限制的，Python 解释器会对栈帧的数量和大小进行限制，以防止栈溢出和资源耗尽的情况发生。在编写 Python 程序时，合理使用函数调用和栈帧可以帮助提高程序的性能和可维护性。
\subsection{栈帧数据结构}
\begin{lstlisting}[style=cpp,caption=, language=C++]

typedef struct _frame {
    PyObject_VAR_HEAD
    struct _frame *f_back;      /* previous frame, or NULL */
    PyCodeObject *f_code;       /* code segment */
    PyObject *f_builtins;       /* builtin symbol table (PyDictObject) */
    PyObject *f_globals;        /* global symbol table (PyDictObject) */
    PyObject *f_locals;         /* local symbol table (any mapping) */
    PyObject **f_valuestack;    /* points after the last local */
    /* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.
       Frame evaluation usually NULLs it, but a frame that yields sets it
       to the current stack top. */
    PyObject **f_stacktop;
    PyObject *f_trace;          /* Trace function */
    /* In a generator, we need to be able to swap between the exception
       state inside the generator and the exception state of the calling
       frame (which shouldn't be impacted when the generator "yields"
       from an except handler).
       These three fields exist exactly for that, and are unused for
       non-generator frames. See the save_exc_state and swap_exc_state
       functions in ceval.c for details of their use. */
    PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;
    /* Borrowed reference to a generator, or NULL */
    PyObject *f_gen;
    int f_lasti;                /* Last instruction if called */
    /* Call PyFrame_GetLineNumber() instead of reading this field
       directly.  As of 2.3 f_lineno is only valid when tracing is
       active (i.e. when f_trace is set).  At other times we use
       PyCode_Addr2Line to calculate the line from the current
       bytecode index. */
    int f_lineno;               /* Current line number */
    int f_iblock;               /* index in f_blockstack */
    char f_executing;           /* whether the frame is still executing */
    PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */
    PyObject *f_localsplus[1];  /* locals+stack, dynamically sized */
} PyFrameObject;
\end{lstlisting}
\subsection{内存申请和栈帧的内存布局}
在 cpython 当中，当我们需要申请一个 frame object 对象的时候，首先需要申请内存空间，但是在申请内存空间的时候并不是单单申请一个 frameobject 大小的内存，而是会申请额外的内存空间，大致布局如下所示。

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/71-frame.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
\begin{itemize}
\item f\_localsplus，这是一个数组用户保存函数执行的 local 变量，这样可以直接通过下标得到对应的变量的值。 
\item ncells 和 nfrees，这个变量和我们前面在分析 code object 的函数闭包相关，ncells 和 ncells 分别表示 cellvars 和 freevars 中变量的个数。 
\item stack，这个变量就是函数执行的时候函数的栈帧，这个大小在编译期间就可以确定因此可以直接确定栈空间的大小。 
\end{itemize}
下面是在申请 frame object 的核心代码：
\begin{lstlisting}[style=cpp,caption=, language=C++]

    Py_ssize_t extras, ncells, nfrees;
    ncells = PyTuple_GET_SIZE(code->co_cellvars); // 得到 co_cellvars 当中元素的个数 没有的话则是 0
    nfrees = PyTuple_GET_SIZE(code->co_freevars); // 得到 co_freevars 当中元素的个数 没有的话则是 0
    // extras 就是表示除了申请 frame object 自己的内存之后还需要额外申请多少个 指针对象
    // 确切的带来说是用于保存 PyObject 的指针
    extras = code->co_stacksize + code->co_nlocals + ncells +
        nfrees;
    if (free_list == NULL) {
        f = PyObject_GC_NewVar(PyFrameObject, &PyFrame_Type,
        extras);
        if (f == NULL) {
            Py_DECREF(builtins);
            return NULL;
        }
    }
    // 这个就是函数的 code object 对象 将其保存到栈帧当中 f 就是栈帧对象
    f->f_code = code;
    extras = code->co_nlocals + ncells + nfrees;
    // 这个就是栈顶的位置 注意这里加上的 extras 并不包含栈的大小
    f->f_valuestack = f->f_localsplus + extras;
    // 对额外申请的内存空间尽心初始化操作
    for (i=0; i<extras; i++)
        f->f_localsplus[i] = NULL;
    f->f_locals = NULL;
    f->f_trace = NULL;
    f->f_exc_type = f->f_exc_value = f->f_exc_traceback = NULL;
    f->f_stacktop = f->f_valuestack; // 将栈顶的指针指向栈的起始位置
    f->f_builtins = builtins;
    Py_XINCREF(back);
    f->f_back = back;
    Py_INCREF(code);
    Py_INCREF(globals);
    f->f_globals = globals;
    /* Most functions have CO_NEWLOCALS and CO_OPTIMIZED set. */
    if ((code->co_flags & (CO_NEWLOCALS | CO_OPTIMIZED)) ==
        (CO_NEWLOCALS | CO_OPTIMIZED))
        ; /* f_locals = NULL; will be set by PyFrame_FastToLocals() */
    else if (code->co_flags & CO_NEWLOCALS) {
        locals = PyDict_New();
        if (locals == NULL) {
            Py_DECREF(f);
            return NULL;
        }
        f->f_locals = locals;
    }
    else {
        if (locals == NULL)
            locals = globals;
        Py_INCREF(locals);
        f->f_locals = locals;
    }
    f->f_lasti = -1;
    f->f_lineno = code->co_firstlineno;
    f->f_iblock = 0;
    f->f_executing = 0;
    f->f_gen = NULL;
\end{lstlisting}
现在我们对 frame object 对象当中的各个字段进行分析，说明他们的作用：
\begin{itemize}
\item PyObject\_VAR\_HEAD：表示对象的头部信息，包括引用计数和类型信息。 
\item f\_back：前一个栈帧对象的指针，或者为NULL。 
\item f\_code：指向 PyCodeObject 对象的指针，表示当前帧执行的代码段。 
\item f\_builtins：指向 PyDictObject 对象的指针，表示当前帧的内置符号表，字典对象，键是字符串，值是对应的 python 对象。 
\item f\_globals：指向 PyDictObject 对象的指针，表示当前帧的全局符号表。 
\item f\_locals：指向任意映射对象的指针，表示当前帧的局部符号表。 
\item f\_valuestack：指向当前帧的值栈底部的指针。 
\item f\_stacktop：指向当前帧的值栈顶部的指针。 
\item f\_trace：指向跟踪函数对象的指针，用于调试和追踪代码执行过程，这个字段我们在后面的文章当中再进行分析。 
\item f\_exc\_type、f\_exc\_value、f\_exc\_traceback：这个字段和异常相关，在函数执行的时候可能会产生错误异常，这个就是用于处理异常相关的字段。 
\item f\_gen：指向当前生成器对象的指针，如果当前帧不是生成器，则为NULL。 
\item f\_lasti：上一条指令在字节码当中的下标。 
\item f\_lineno：当前执行的代码行号。 
\item f\_iblock：当前执行的代码块在f\_blockstack中的索引，这个字段也主要和异常的处理有关系。 
\item f\_executing：表示当前帧是否仍在执行。 
\item f\_blockstack：用于try和loop代码块的堆栈，最多可以嵌套 CO\_MAXBLOCKS 层。 
\item f\_localsplus：局部变量和值栈的组合，是一个动态大小的数组。 
\end{itemize}
如果我们在一个函数当中调用另外一个函数，这个函数再调用其他函数就会形成函数的调用链，就会形成下图所示的链式结构。

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/72-frame.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
\subsection{例子分析}
我们现在来模拟一下下面的函数的执行过程。
\begin{lstlisting}[style=py,caption=, language=Python]

import dis
def foo():
    a = 1
    b = 2
    return a + b
if __name__ == '__main__':
    dis.dis(foo)
    print(foo.__code__.co_stacksize)
    foo()
\end{lstlisting}
上面的 foo 函数的字节码如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

  6           0 LOAD_CONST               1 (1)
              2 STORE_FAST               0 (a)
  7           4 LOAD_CONST               2 (2)
              6 STORE_FAST               1 (b)
  8           8 LOAD_FAST                0 (a)
             10 LOAD_FAST                1 (b)
             12 BINARY_ADD
             14 RETURN_VALUE
\end{lstlisting}
函数 foo 的 stacksize 等于 2 。
初始时 frameobject 的布局如下所示：

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/73-frame.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
现在执行第一条指令 LOAD\_CONST 此时的 f\_lasti 等于 -1，执行完这条字节码之后栈帧情况如下：

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/74-frame.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
在执行完这条字节码之后 f\_lasti 的值变成 0。字节码 LOAD\_CONST 对应的 c 源代码如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

TARGET(LOAD_CONST) {
    PyObject *value = GETITEM(consts, oparg); // 从常量表当中取出下标为 oparg 的对象
    Py_INCREF(value);
    PUSH(value);
    FAST_DISPATCH();
}
\end{lstlisting}
首先是从 consts 将对应的常量拿出来，然后压入栈空间当中。
再执行 STORE\_FAST 指令，这个指令就是将栈顶的元素弹出然后保存到前面提到的 f\_localsplus 数组当中去，那么现在栈空间是空的。STORE\_FAST 对应的 c 源代码如下：
\begin{lstlisting}[style=cpp,caption=, language=C++]

TARGET(STORE_FAST) {
    PyObject *value = POP(); // 将栈顶元素弹出
    SETLOCAL(oparg, value);  // 保存到 f_localsplus 数组当中去
    FAST_DISPATCH();
}
\end{lstlisting}
执行完这条指令之后 f\_lasti 的值变成 2 。
接下来的两条指令和上面的一样，就不做分析了，在执行完两条指令，f\_lasti 变成 6 。
接下来两条指令分别将 a b 加载进入栈空间单中现在栈空间布局如下所示：

    \begin{figure}[H]
        \centering
            \includegraphics[scale=.25]{images/75-frame.png}
						\caption{ }
        \label{fig:my_label}
    \end{figure}
    
然后执行 BINARY\_ADD 指令 弹出栈空间的两个元素并且把他们进行相加操作，最后将得到的结果再压回栈空间当中。
\begin{lstlisting}[style=cpp,caption=, language=C++]

TARGET(BINARY_ADD) {
    PyObject *right = POP();
    PyObject *left = TOP();
    PyObject *sum;
    if (PyUnicode_CheckExact(left) &&
             PyUnicode_CheckExact(right)) {
        sum = unicode_concatenate(left, right, f, next_instr);
        /* unicode_concatenate consumed the ref to left */
    }
    else {
        sum = PyNumber_Add(left, right);
        Py_DECREF(left);
    }
    Py_DECREF(right);
    SET_TOP(sum); // 将结果压入栈中
    if (sum == NULL)
        goto error;
    DISPATCH();
}
\end{lstlisting}
最后执行 RETURN\_VALUE 指令将栈空间结果返回。
\subsection{总结}
在本小节当中主要介绍了 cpython 当中的函数执行的时候的栈帧结构，这里面包含的程序执行时候所需要的一些必要的变量，比如说全局变量，python 内置的一些对象等等，同时需要注意的是 python 在查询对象的时候如果本地 f\_locals 没有找到就会去全局 f\_globals 找，如果还没有找到就会去 f\_builtins 里面的找，当一个程序返回的时候就会找到 f\_back 他上一个执行的栈帧，将其设置成当前线程正在使用的栈帧，这就完成了函数的调用返回，关于这个栈帧还有一些其他的字段我们没有谈到在后续的文章当中将继续深入其中一些字段。

