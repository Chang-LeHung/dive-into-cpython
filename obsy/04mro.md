# 深入理解 python 虚拟机：多继承与 mro

在本篇文章当中将主要给大家介绍 python 当中的多继承和 mro，通过介绍在多继承当中存在的问题就能够理解在 cpython 当中引入 c3 算法的原因了，从而能够帮助大家更好的了理解 mro 。

## python 继承的问题

继承是一种面向对象编程的概念，它可以让一个类（子类）继承另一个类（父类）的属性和方法。子类可以重写父类的方法，或者添加自己的方法和属性。这种机制使得代码可以更加模块化和易于维护。在 Python 中，继承是通过在子类的定义中指定父类来实现的。例如：

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        raise NotImplementedError("Subclass must implement abstract method")

class Dog(Animal):
    def speak(self):
        return "woof"
```

在这个例子中，我们定义了一个 `Animal` 类和一个 `Dog` 类。`Dog` 类继承了 `Animal` 类，并且重写了 `speak` 方法。此时，如果我们创建一个 `Dog` 实例并调用 `speak` 方法，它将返回 `"woof"`。

### 父类的修改会影响子类

当你修改父类的代码时，可能会影响到继承自它的子类。这是因为子类继承了父类的所有属性和方法，包括它们的实现。如果你修改了父类的实现，可能会导致子类的行为发生变化。因此，在修改父类代码时，你需要仔细考虑这个问题，并尽量避免对子类的影响。

### 多层继承的复杂性

在面向对象编程中，有时需要多层继承，即一个类继承自另一个继承自另一个类。这会导致代码的复杂性增加，因为你需要考虑每个类之间的关系和可能出现的命名冲突。另外，多层继承也会增加代码的耦合性，使得代码难以重构和维护。

多继承当中一个非常经典的问题就是棱形继承，菱形继承是指一个子类继承了两个父类，而这两个父类又继承自同一个基类的情况，如下图所示：

```bash
   A
  / \
 B   C
  \ /
   D
```

在这种情况下，子类 `D` 会继承两份来自基类 `A` 的属性和方法，这可能会导致一些不必要的问题。例如，如果基类 `A` 中有一个名为 `foo()` 的方法，而基类 `B` 和 `C` 都分别重写了这个方法，并在子类 `D` 中调用了这个方法，那么子类 `D` 就无法确定应该调用哪个版本的 `foo()` 方法。

## MRO

在 Python 中，多重继承会引起 MRO（Method Resolution Order，方法解析顺序）问题。当一个类继承自多个父类时，Python 需要确定方法调用的顺序，即优先调用哪个父类的方法。为了解决这个问题，Python 实现了一种称为 C3算法的 MRO 算法，它是一种确定方法解析顺序的算法。

### C3 算法

C3 算法是 Python 中使用的 MRO 算法，它可以用来确定一个类的方法解析顺序。该算法的具体步骤如下：

1. 创建一个 MRO 列表，包含当前类以及它的所有父类。
2. 找出 MRO 列表中所有头部元素（即第一个元素），并将它们放在一个集合中。
3. 如果这个集合中只包含一个元素，则将它添加到解析顺序列表中，并从 MRO 列表和所有父类的 MRO 列表中删除这个元素。否则，继续下一步。
4. 对于集合中的每个元素，检查它是否是所有头部元素的超类。如果是，则将它添加到解析顺序列表中，并从 MRO 列表和所有父类的 MRO 列表中删除这个元素。否则，继续下一步。
5. 如果找不到符合条件的元素，则抛出一个异常。否则，返回解析顺序列表。

下面是一个使用多重继承的示例：

```python
class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B, C):
    pass
```

在这个示例中，`D` 类继承自 `B` 类和 `C` 类，而 `B` 和 `C` 又都继承自 `A` 类。因此，`D` 类的 MRO 列表如下所示：

```python
[D, B, C, A]
```

这个列表的解析顺序为 `D -> B -> C -> A`，也就是说，当我们调用 `D` 类的方法时，Python 会首先查找 `D` 类的方法，然后查找 `B` 类的方法，再查找 `C` 类的方法，最后查找 `A` 类的方法。
