import{_ as n,o as s,c as a,e}from"./app-6b5e6c63.js";const p={},t=e(`<h1 id="深入理解python虚拟机-super的超级魔法" tabindex="-1"><a class="header-anchor" href="#深入理解python虚拟机-super的超级魔法" aria-hidden="true">#</a> 深入理解Python虚拟机：super的超级魔法</h1><h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h2><p>在本篇文章中，我们将深入探讨Python中的<code>super</code>函数的使用和原理。<code>super</code>函数作为Python虚拟机中强大的功能之一，可以帮助我们更灵活地使用继承和多重继承。</p><h2 id="super函数的使用" tabindex="-1"><a class="header-anchor" href="#super函数的使用" aria-hidden="true">#</a> super函数的使用</h2><p>在Python中，我们经常使用继承来构建类的层次结构。当子类继承了父类的属性和方法时，有时我们需要在子类中调用父类的方法或属性。这就是<code>super</code>函数的用武之地。</p><p><code>super</code>函数的一般用法是在子类中调用父类的方法，格式为<code>super().method()</code>。这样可以方便地使用父类的实现，并在子类中添加自己的特定行为。</p><p>下面是一个示例代码，演示了<code>super</code>函数的使用：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
    
    <span class="token keyword">def</span> <span class="token function">say_hello</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;Hello, I&#39;m </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span><span class="token punctuation">(</span>Parent<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>name<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>age <span class="token operator">=</span> age
    
    <span class="token keyword">def</span> <span class="token function">say_hello</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>say_hello<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;I&#39;m </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> and I&#39;m </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>age<span class="token punctuation">}</span></span><span class="token string"> years old&quot;</span></span><span class="token punctuation">)</span>

child <span class="token operator">=</span> Child<span class="token punctuation">(</span><span class="token string">&quot;Alice&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
child<span class="token punctuation">.</span>say_hello<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Hello, I&#39;m Alice
I&#39;m Alice and I&#39;m 10 years old
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，<code>Child</code>类继承自<code>Parent</code>类。在<code>Child</code>类的构造函数中，我们使用<code>super().__init__(name)</code>来调用父类<code>Parent</code>的构造函数，以便在子类中初始化父类的属性。在<code>say_hello</code>方法中，我们使用<code>super().say_hello()</code>调用父类<code>Parent</code>的<code>say_hello</code>方法，并在子类中添加了额外的输出。</p><p>除了调用父类的方法，<code>super</code>函数还可以用于访问父类的属性。例如，<code>super().attribute</code>可以用来获取父类的属性值。</p><h2 id="super函数的原理" tabindex="-1"><a class="header-anchor" href="#super函数的原理" aria-hidden="true">#</a> super函数的原理</h2><p>要理解<code>super</code>函数的原理，我们需要了解Python中的多重继承和方法解析顺序（Method Resolution Order，MRO）。</p><p>多重继承是指一个类可以同时继承多个父类。在Python中，每个类都有一个内置属性<code>__mro__</code>，它记录了方法解析顺序。MRO是根据C3线性化算法生成的，它决定了在多重继承中调用方法的顺序。</p><p><code>super</code>函数的实现原理是根据当前类的MRO找到下一个要调用的方法。它通过检查当前类的MRO列表，找到下一个类的方法，并返回一个绑定了下一个类的实例。这意味着当我们在子类中调用<code>super().method()</code>时，实际上是在调用父类的方法。</p><h2 id="cpython的实现" tabindex="-1"><a class="header-anchor" href="#cpython的实现" aria-hidden="true">#</a> CPython的实现</h2><p>CPython是Python的默认解释器，它使用C语言实现。在CPython中，<code>super</code>函数的实现是通过查找对象的<code>__class__</code>属性来确定下一个要调用的方法。<code>__class__</code>属性指向对象所属的类。</p><p>CPython使用<code>PyTypeObject</code>结构体来表示每个类。该结构体包含了类的名称、父类、方法表等信息。在方法表中，每个方法都有一个指向实际函数的指针。</p><p>当使用<code>super</code>函数时，CPython会根据当前对象的<code>__class__</code>属性和方法名，在父类的方法表中找到对应的方法，并调用它。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p><code>super</code>函数是Python中重要的功能之一，它允许我们方便地调用父类的方法和访问父类的属性。它的实现原理是根据当前类的MRO找到下一个要调用的方法。在CPython中，<code>super</code>函数的实现是通过查找对象的<code>__class__</code>属性来确定下一个要调用的方法。</p><p>通过深入理解<code>super</code>函数的使用和原理，我们可以更好地利用继承和多重继承的强大功能，编写出更灵活、可维护的Python代码。</p><p>希望本文对您对<code>super</code>函数有所帮助。如有任何疑问，请随时提问。</p>`,24),o=[t];function c(i,l){return s(),a("div",null,o)}const d=n(p,[["render",c],["__file","07super.html.vue"]]);export{d as default};
