# Python 3.14 新特性

10 月 7 日 Python 3.14 正式发布，该版本又是一个有着巨大提升的版本，可以说是继 Python 3.12 和 Python 3.13 之后的又一个史诗级版本，话不多说，此次更新最主要内容如下：

- Python 开始彻底多线程特性，移除了 GIL 的限制，在一个 Python 进程中可以启动多个 Interpreter，Interpreter 之间的线程没有 GIL，真正实现了多线程并发执行。Python 标准库中提供了明确的支持。
- 增加了一个新的 interpreter ，主要使用 clang-19 提供 tail-call 的能力，能够提升整个解释器的执行效率。
- 新增一个外部调试接口，可以直接通过进程号对 Python 程序进行调试。
- 延迟解析类型注解。
- Asyncio 支持通过进程号的方式了解 asyncio 的运行情况，展示 asyncio 中的任务依赖树，提供了类似 pstree 的功能。

## 单进程多解释器

## Tail-Call 优化解释器

该解释器主要是使用 clang-19 提供的一种编译调用规约（Calling Convention）来进行解释器本身的优化。所谓调用规约就是在汇编语言层面确定调用者和被调用者之间的参数是如何的传递的一种约定。

### 调用规约

以 System V AMD64 ABI 调用规约（主要使用在 Linux 、FreeBSD 等操作系统）为例子，下表表示各个通用寄存器的保存和恢复约定。

| 寄存器类型       | 寄存器名称 | 说明                             |
| ---------------- | ---------- | -------------------------------- |
| **Caller Saved** | %rax       | 返回值寄存器，调用者负责保存     |
|                  | %rcx       | 第 4 个整数参数，调用者负责保存  |
|                  | %rdx       | 第 3 个整数参数，调用者负责保存  |
|                  | %rsi       | 第 2 个整数参数，调用者负责保存  |
|                  | %rdi       | 第 1 个整数参数，调用者负责保存  |
|                  | %r8        | 第 5 个整数参数，调用者负责保存  |
|                  | %r9        | 第 6 个整数参数，调用者负责保存  |
|                  | %r10       | 临时寄存器，调用者负责保存       |
|                  | %r11       | 临时寄存器，调用者负责保存       |
| **Callee Saved** | %rbx       | 被调用者必须保存和恢复           |
|                  | %rbp       | 栈帧指针，被调用者必须保存和恢复 |
|                  | %r12       | 被调用者必须保存和恢复           |
|                  | %r13       | 被调用者必须保存和恢复           |
|                  | %r14       | 被调用者必须保存和恢复           |
|                  | %r15       | 被调用者必须保存和恢复           |
| **特殊**         | %rsp       | 栈指针，由被调用者维护           |

在函数调用过程中，Caller Saved 寄存器的值可能被被调用函数修改，因此调用者在调用前需要保存这些寄存器的值。而 Callee Saved 寄存器必须由被调用函数负责保存和恢复，保证调用前后值不变，比如一个被调用的函数在编译的时候如果需要使用寄存器 %r12，那么他就需要在函数返回之间将这个寄存器恢复成函数刚调用时的值。

### Callee Saved 寄存器示例

以下是一个简单的 C 语言例子 `demo.c`，展示被调用函数必须保存和恢复 Callee Saved 寄存器：

```c
#include <stdio.h>

int callee_function(int a, int b) {

    int register c = a + b  + 100;

    int register result = c * 2 + b * 4 + a * 8;

    return result;
}

int main() {
    int x = 42;

    int result = callee_function(10, 20);
    printf("x = %d, result = %d\n", x, result);
    return 0;
}
```

```bash
gcc -c demo.c
```

上面的例子编译之后得到的汇编结果如下

```asm
0000000000000000 <callee_function>:
   0:   f3 0f 1e fa             endbr64
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   53                      push   %rbx
   9:   89 7d f4                mov    %edi,-0xc(%rbp)
   c:   89 75 f0                mov    %esi,-0x10(%rbp)
   f:   8b 55 f4                mov    -0xc(%rbp),%edx
  12:   8b 45 f0                mov    -0x10(%rbp),%eax
  15:   01 d0                   add    %edx,%eax
  17:   8d 58 64                lea    0x64(%rax),%ebx
  1a:   8b 45 f0                mov    -0x10(%rbp),%eax
  1d:   01 c0                   add    %eax,%eax
  1f:   8d 14 03                lea    (%rbx,%rax,1),%edx
  22:   8b 45 f4                mov    -0xc(%rbp),%eax
  25:   c1 e0 02                shl    $0x2,%eax
  28:   01 d0                   add    %edx,%eax
  2a:   8d 1c 00                lea    (%rax,%rax,1),%ebx
  2d:   89 d8                   mov    %ebx,%eax
  2f:   5b                      pop    %rbx
  30:   5d                      pop    %rbp
  31:   c3                      retq
```

在上面的汇编程序中使用到了 `rbx` 和 `ebx` 这两个寄存器，而这个寄存器是一个 Callee Saved 寄存器（被调用者保存的寄存器），因此在函数开始时会将 `rbx` 的值保存到栈中（`push %rbx`），在函数返回之前再将其恢复（`pop %rbx`），这就是调用规约的基本的工作原理。

如果在函数 `callee_function` 中没有保存和恢复 `rbx` 寄存器，而在调用它的函数中使用到了该寄存器，那么程序的行为将是未定义的，可能会导致程序崩溃或者结果错误，因为编译器在按照调用规约编译的时候默认 `rbx` 寄存器的值是不会被 Callee 修改的。

## 外部调试接口
