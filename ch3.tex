\chapter{对象系统}
\section{黑科技的幕后英雄——描述器}
在本小节当中主要给大家介绍一个我们在使用类的时候经常使用但是却很少在意的黑科技——描述器，在本小节当中主要分析描述器的原理，以及介绍使用描述器实现属性访问控制和 orm 映射等等功能！在后面的文章当中我们将继续去分析描述器的实现原理。
\subsection{描述器的基本用法}
描述器是一个实现了 \verb|__get__|、\verb|__set__| 或 \verb|__delete__| 中至少一个方法的 Python 类。这些方法分别用于在属性被访问、设置或删除时调用。当一个描述器被定义为一个类的属性时，它可以控制该属性的访问、修改和删除。
下面是一个示例，演示了如何定义一个简单的描述器：
\begin{lstlisting}[style=py,caption=, language=Python]

class Descriptor:
    def __get__(self, instance, owner):
        print(f"Getting {self.__class__.__name__}")
        return instance.__dict__.get(self.attrname)
    def __set__(self, instance, value):
        print(f"Setting {self.__class__.__name__}")
        instance.__dict__[self.attrname] = value
    def __delete__(self, instance):
        print(f"Deleting {self.__class__.__name__}")
        del instance.__dict__[self.attrname]
    def __set_name__(self, owner, name):
        self.attrname = name
\end{lstlisting}
在这个例子中，我们定义了一个名为 Descriptor 的描述器类，它有三个方法：\verb|__get__|、\verb|__set__| 和 \verb|__delete__|。当我们在另一个类中使用这个描述器时，这些方法将被调用，以控制该类的属性的访问和修改。
要使用这个描述器，我们可以在另一个类中将其定义为一个类属性：
\begin{lstlisting}[style=py,caption=, language=Python]

class MyClass:
    x = Descriptor()
\end{lstlisting}
现在，我们可以创建一个 MyClass 对象并访问其属性：
\begin{lstlisting}[style=py,caption=, language=Python]

>>> obj = MyClass()
>>> obj.x = 1
Setting Descriptor
>>> obj.x
Getting Descriptor
1
>>> del obj.x
Deleting Descriptor
>>> obj.x
Getting Descriptor
\end{lstlisting}
在这个例子中，我们首先创建了一个 MyClass 对象，并将其 x 属性设置为 1。然后，我们再次访问 x 属性时，会调用 \verb|__get__| 方法并返回 1。最后，我们删除了 x 属性，并再次访问它时，会调用 \verb|__get__| 方法并返回 None。从上面的输出结果可以看到对应的方法都被调用了，这是符合上面对描述器的定义的。如果一个类对象不是描述器，那么在使用对应的属性的时候是不会调用\verb|__get__|、\verb|__set__| 和 \verb|__delete__|三个方法的。比如下面的代码：
\begin{lstlisting}[style=py,caption=, language=Python]

class NonDescriptor(object):
    pass
class MyClass():
    nd = NonDescriptor()
if __name__ == '__main__':
    a = MyClass()
    print(a.nd)
\end{lstlisting}
上面的代码输出结果如下所示：
\begin{lstlisting}[style=py,caption=, language=Python]

<__main__.NonDescriptor object at 0x1012cce20>
\end{lstlisting}
从上面程序的输出结果可以知道，当使用一个非描述器的类属性的时候是不会调用对应的方法的，而是直接得到对应的对象。
\subsection{描述器的实现原理}
描述器的实现原理可以用以下三个步骤来概括：
\begin{itemize}
\item 当一个类的属性被访问时，Python 解释器会检查该属性是否是一个描述器。如果是，它会调用描述器的 \verb|__get__| 方法，并将该类的实例作为第一个参数，该实例所属的类作为第二个参数，并将属性名称作为第三个参数传递给 \verb|__get__| 方法。 
\item 当一个类的属性被设置时，Python 解释器会检查该属性是否是一个描述器。如果是，它会调用描述器的 \verb|__set__| 方法，并将该类的实例作为第一个参数，设置的值作为第二个参数，并将属性名称作为第三个参数传递给 \verb|__set__| 方法。 
\item 当一个类的属性被删除时，Python 解释器会检查该属性是否是一个描述器。如果是，它会调用描述器的 \verb|__delete__| 方法，并将该类的实例作为第一个参数和属性名称作为第二个参数传递给 \verb|__delete__| 方法。 
\end{itemize}
在描述器的实现中，通常还会使用 \verb|__set_name__| 方法来在描述器被绑定到类属性时设置属性名称。这使得描述器可以在被多个属性使用时，正确地识别每个属性的名称。
现在来仔细了解一下上面的几个函数的参数，我们以下面的代码为例子进行说明：
\begin{lstlisting}[style=py,caption=, language=Python]

class Descriptor(object):
    def __set_name__(self, obj_type, attr_name):
        print(f"__set_name__ : {obj_type } {attr_name = }")
        return "__set_name__"
    def __get__(self, obj, obj_type):
        print(f"__get__ : {obj = } { obj_type = }")
        return "__get__"
    def __set__(self, instance, value):
        print(f"__set__ : {instance = } {value = }")
        return "__set__"
    def __delete__(self, obj):
        print(f"__delete__ : {obj = }")
        return "__delete__"
class MyClass(object):
    des = Descriptor()
if __name__ == '__main__':
    a = MyClass()
    _ = MyClass.des
    _ = a.des
    a.des = "hello"
    del a.des
\end{lstlisting}
上面的代码输入结果如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

__set_name__ : <class '__main__.MyClass'> attr_name = 'des'
__get__ : obj = None  obj_type = <class '__main__.MyClass'>
__get__ : obj = <__main__.MyClass object at 0x1054abeb0>  obj_type = <class '__main__.MyClass'>
__set__ : instance = <__main__.MyClass object at 0x1054abeb0> value = 'hello'
__delete__ : obj = <__main__.MyClass object at 0x1054abeb0>
\end{lstlisting}
\begin{itemize}
\item \verb|__set_name__| 这个函数一共有两个参数传入的参数第一个参数是使用描述器的类，第二个参数是使用这个描述器的类当中使用的属性名字，在上面的例子当中就是 "des" 。 
\item \verb|__get__|，这个函数主要有两个参数，一个是使用属性的对象，另外一个是对象的类型，如果是直接使用类名使用属性的话，obj 就是 None，比如上面的 MyClass.des 。 
\item \verb|__set__|，这个函数主要有两个参数一个是对象，另外一个是需要设置的值。 
\item \verb|__delete__|，这函数有一个参数，就是传入的对象，比如 del a.des 传入的就是对象 a 。 
\end{itemize}
\subsection{描述器的应用场景}
描述器在 Python 中有很多应用场景。以下是其中的一些示例：
\subsubsection{实现属性访问控制}
通过使用描述器，可以实现对类属性的访问控制，例如只读属性、只写属性、只读/只写属性等。通过在 \verb|__get__| 和 \verb|__set__| 方法中添加相应的访问控制逻辑，可以限制对类属性的访问和修改。
\begin{lstlisting}[style=py,caption=, language=Python]

class ReadOnly:
    def __init__(self, value):
        self._value = value
    
    def __get__(self, instance, owner):
        return self._value
    
    def __set__(self, instance, value):
        raise AttributeError("Read only attribute")
        
class MyClass:
    read_only_prop = ReadOnly(42)
    writeable_prop = None
    
my_obj = MyClass()
print(my_obj.read_only_prop)  \section{42}
my_obj.writeable_prop = "hello"
print(my_obj.writeable_prop)  \section{hello}
my_obj.read_only_prop = 100  \section{raises AttributeError}
\end{lstlisting}
在上面的例子中，\verb|ReadOnly| 描述器只实现了 \verb|__get__| 方法，而 \verb|__set__| 方法则抛出了 \verb|AttributeError| 异常，从而实现了只读属性的访问控制。
\subsubsection{实现数据验证和转换}
描述器还可以用于实现数据验证和转换逻辑。通过在 \verb|__set__| 方法中添加数据验证和转换逻辑，可以确保设置的值符合某些特定的要求。例如，可以使用描述器来确保设置的值是整数、在某个范围内、符合某个正则表达式等。
\begin{lstlisting}[style=py,caption=, language=Python]

class Bounded:
    def __init__(self, low, high):
        self._low = low
        self._high = high
    
    def __get__(self, instance, owner):
        return self._value
    
    def __set__(self, instance, value):
        if not self._low <= value <= self._high:
            raise ValueError(f"Value must be between {self._low} and {self._high}")
        self._value = value
class MyClass:
    bounded_prop = Bounded(0, 100)
my_obj = MyClass()
my_obj.bounded_prop = 50
print(my_obj.bounded_prop)  \section{50}
my_obj.bounded_prop = 200  \section{raises ValueError}
\end{lstlisting}
在上面的例子中，\verb|Bounded| 描述器在 \verb|__set__| 方法中进行了数值范围的检查，如果值不在指定范围内，则抛出了 \verb|ValueError| 异常。
\subsubsection{实现延迟加载和缓存}
描述器还可以用于实现延迟加载和缓存逻辑。通过在 \verb|__get__| 方法中添加逻辑，可以实现属性的延迟加载，即当属性第一次被访问时才进行加载。此外，还可以使用描述器来实现缓存逻辑，以避免重复计算。
\begin{lstlisting}[style=py,caption=, language=Python]

class LazyLoad:
    def __init__(self, func):
        self._func = func
    def __get__(self, instance, owner):
        if instance is None:
            return self
        value = self._func(instance)
        setattr(instance, self._func.__name__, value)
        return value
class MyClass:
    def __init__(self):
        self._expensive_data = None
    @LazyLoad
    def expensive_data(self):
        print("Calculating expensive data...")
        self._expensive_data = [i ** 2 for i in range(10)]
        return self._expensive_data
my_obj = MyClass()
print(my_obj.expensive_data)  \section{Calculating expensive data... }
print(my_obj.expensive_data)
\end{lstlisting}
上面的程序的输出结果如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

Calculating expensive data...
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
\end{lstlisting}
从上面的结果可以看到，只有在第一次使用属性的时候才调用函数，后续再次调用函数将不会再调用函数而是直接返回缓存的结果。
\subsubsection{实现 ORM 映射}
ORM 的主要作用是把数据库中的关系数据转化为面向对象的数据，让开发者可以通过编写面向对象的代码来操作数据库。ORM 技术可以把面向对象的编程语言和关系数据库之间的映射关系抽象出来，开发者可以不用写 SQL 语句，而是直接使用面向对象的语法进行数据库操作。
我们现在需要实现一个功能，user.name 直接从数据库的 user 表当中查询 name 等于 user.name 的数据，user.name = "xxx" 根据 user 的主键 id 进行更新数据。这个功能我们就可以使用描述器实现，因为只需要了解如何使用描述器的，因此在下面的代码当中并没有连接数据库：
\begin{lstlisting}[style=py,caption=, language=Python]

conn = dict()
class Field:
    def __set_name__(self, owner, name):
        self.fetch = f'SELECT {name} FROM {owner.table} WHERE {owner.key}=?;'
        print(f"{self.fetch = }")
        self.store = f'UPDATE {owner.table} SET {name}=? WHERE {owner.key}=?;'
        print(f"{self.store = }")
    def __get__(self, obj, objtype=None):
        return conn.execute(self.fetch, [obj.key]).fetchone()[0]
    def __set__(self, obj, value):
        conn.execute(self.store, [value, obj.key])
        conn.commit()
class User:
    table = 'User'                    \section{Table name}
    key = 'id'                       \section{Primary key}
    name = Field()
    age = Field()
    def __init__(self, key):
        self.key = key
if __name__ == '__main__':
    u = User("Bob")
\end{lstlisting}
上面的程序输出结果如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

self.fetch = 'SELECT name FROM User WHERE id=?;'
self.store = 'UPDATE User SET name=? WHERE id=?;'
self.fetch = 'SELECT age FROM User WHERE id=?;'
self.store = 'UPDATE User SET age=? WHERE id=?;
\end{lstlisting}
从上面的输出结果我们可以看到针对 name 和 age 两个字段的查询和更新语句确实生成了，当我们调用 u.name = xxx 或者 u.age = xxx 的时候就执行 \verb|__set__| 函数，就会连接数据库进行相应的操作了。
\subsection{总结}
在本小节当中主要给大家介绍了什么是描述器以及我们能够使用描述器来实现什么样的功能，事实上 python 是一个比较随意的语言，因此我们可以利用很多有意思的语法做出黑多黑科技。python 语言本身也利用描述器实现了很多有意思的功能，比如 property、staticmethod 等等，这些内容我们在后面的文章当中再进行分析。

\section{描述器的王炸应用-property、staticmethod 和 classmehtod}
在本小节当中主要给大家介绍描述器在 python 语言当中有哪些应用，主要介绍如何使用 python 语言实现 python 内置的 proterty 、staticmethod 和 class method 。
\subsection{property}
当你在编写Python代码时，你可能会遇到一些需要通过方法来访问或设置的属性。Python中的 property 装饰器提供了一种优雅的方式来处理这种情况，允许你将这些方法封装为属性，从而使代码更加简洁和易于阅读。在本文中，我将向你介绍 property 装饰器的工作原理以及如何在你的代码中使用它。
\subsubsection{什么是 property？}
Python 中的 property 是一种装饰器，它允许你定义一个方法，使其看起来像一个属性。换句话说，property 允许你以属性的方式访问或设置类的数据成员，而不必直接调用一个方法。
在 Python 中，属性通常是一个对象的数据成员，它们可以通过直接访问对象来获取或设置。然而，有时候你可能需要在获取或设置属性时执行某些额外的操作，例如进行类型检查、范围检查或计算属性等。在这种情况下，使用 property 装饰器可以让你以属性的方式访问或设置这些属性，并在访问或设置时执行额外的操作。
\subsubsection{如何使用 property？}
让我们看一个简单的例子，假设你正在编写一个表示矩形的类，并且你想要在计算矩形的面积时执行一些额外的操作。你可以使用 property 装饰器来实现这个功能，如下所示：
\begin{lstlisting}[style=py,caption=, language=Python]

class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height
    
    @property
    def width(self):
        return self._width
    
    @width.setter
    def width(self, value):
        if value <= 0:
            raise ValueError("Width must be positive")
        self._width = value
    
    @property
    def height(self):
        return self._height
    
    @height.setter
    def height(self, value):
        if value <= 0:
            raise ValueError("Height must be positive")
        self._height = value
    
    @property
    def area(self):
        return self._width * self._height
\end{lstlisting}
在这个示例中，我们使用 property 装饰器定义了三个属性：width、height和area。每个属性都有一个 getter 方法和一个 setter 方法，它们分别负责获取和设置属性的值。当你使用类的实例访问这些属性时，你会发现它们似乎就像是一个普通的属性，而不是一个方法。
注意，getter 方法没有参数，而 setter 方法接受一个参数。当你通过类的实例访问属性时，你只需要使用点运算符即可访问这些属性，就像这样：
\begin{lstlisting}[style=py,caption=, language=Python]

rect = Rectangle(10, 20)
print(rect.width)
print(rect.height)
print(rect.area)
\end{lstlisting}
输出结果：
\begin{lstlisting}[style=cpp,caption=, language=C++]

10
20
200
\end{lstlisting}
你也可以像下面这样设置属性的值：
\begin{lstlisting}[style=py,caption=, language=Python]

rect.width = 5
rect.height = 10
print(rect.width)
print(rect.height)
print(rect.area)
\end{lstlisting}
输出结果如下所示：
\begin{lstlisting}[style=py,caption=, language=Python]
5
10
50
\end{lstlisting}
在设置 width 或 height 属性的值时，会执行对应的 setter 方法进行类型检查和范围检查。如果值不符合要求，将会抛出一个 ValueError 异常。这使得你的代码更加健壮和可靠。
除了在属性的 getter 和 setter 方法中执行额外的操作外，你还可以使用 property 装饰器计算属性。计算属性是指，当你访问属性时，它不是从类的实例中获取数据，而是基于类的其他数据成员进行计算。例如，如果你有一个表示温度的类，你可以定义一个计算属性，用于将摄氏度转换为华氏度，如下所示：
\begin{lstlisting}[style=py,caption=, language=Python]

class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius
    
    @property
    def celsius(self):
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        self._celsius = value
    
    @property
    def fahrenheit(self):
        return (self._celsius * 9/5) + 32
\end{lstlisting}
在这个示例中，我们定义了一个 Temperature 类，它包含一个 celsius 属性和一个 fahrenheit 属性。celsius 属性是一个普通的属性，可以直接访问和设置。而 fahrenheit 属性是一个计算属性，它基于 celsius 属性计算而来。当你访问 fahrenheit 属性时，它将自动计算出相应的华氏度并返回。你可以会对上面的代码有点疑惑\verb|celsius.setter| 是什么，他是那里来的，事实上在它上面的 \verb|@property| 执行之后 celsius 已经不再是一个函数了，而是一个 property 的类产生的对象了，因此 \verb|celsius.setter| 是 property 类中的 \verb|setter| 属性了，事实上他是一个类的方法了，而装饰器 \verb|@celsius.setter| 就是将 \verb|def celsius(self, value)| 这个函数作为参数传递给方法 \verb|celsius.setter|。
我们介绍了 Python 中的 property 装饰器，它允许你将方法封装为属性，并在访问或设置属性时执行额外的操作。通过使用 property 装饰器，你可以编写更加简洁、优雅和可读的代码，同时使代码更加健壮和可靠。
\subsubsection{property 的本质}
property 是 python 内置的一个类，注意它是类。在前面的内容当中我们已经详细讨论过了装饰器的原理，并且从字节码的角度进行了分析。因此我们可以很容易理解上面 \verb|Temperature| 类。我们可以将装饰器展开：
\begin{lstlisting}[style=py,caption=, language=Python]

class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius
    def celsius1(self):
        return self._celsius
    celsius = property(celsius1)
    def celsius2(self, value):
        self._celsius = value
    celsius = celsius.setter(celsius2)
    def fahrenheit(self):
        return (self._celsius * 9 / 5) + 32
    fahrenheit = property(fahrenheit)
if __name__ == '__main__':
    t = Temperature(10)
    print(t.celsius)
    t.celsius = 100
    print(t.celsius)
    print(t.fahrenheit)
\end{lstlisting}
上面的程序输出结果如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

10
100
212.0
\end{lstlisting}
可以看到上面的程序正确的输出了结果，符合我们对与 property 的理解和使用。从上面的分析我们可以看到 property 本质就是一个 python 的类，因此我可以完全自己实现一个和内置的 property 类相同功能的类。
\subsubsection{在 python 语言层面实现 property 机制}
具体的实现代码如下所示：
\begin{lstlisting}[style=py,caption=, language=Python]

class Property:
    "Emulate PyProperty_Type() in Objects/descrobject.c"
    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        if doc is None and fget is not None:
            doc = fget.__doc__
        self.__doc__ = doc
        self._name = ''
    def __set_name__(self, owner, name):
        self._name = name
    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError(f"property '{self._name}' has no getter")
        return self.fget(obj)
    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError(f"property '{self._name}' has no setter")
        self.fset(obj, value)
    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError(f"property '{self._name}' has no deleter")
        self.fdel(obj)
    def getter(self, fget):
        prop = type(self)(fget, self.fset, self.fdel, self.__doc__)
        prop._name = self._name
        return prop
    def setter(self, fset):
        prop = type(self)(self.fget, fset, self.fdel, self.__doc__)
        prop._name = self._name
        return prop
    def deleter(self, fdel):
        prop = type(self)(self.fget, self.fset, fdel, self.__doc__)
        prop._name = self._name
        return prop
\end{lstlisting}
现在对上面我们自己实现的类对象进行使用测试：
\begin{lstlisting}[style=py,caption=, language=Python]

class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height
    @Property
    def width(self):
        return self._width
    @width.setter
    def width(self, value):
        if value <= 0:
            raise ValueError("Width must be positive")
        self._width = value
    @Property
    def height(self):
        return self._height
    @height.setter
    def height(self, value):
        if value <= 0:
            raise ValueError("Height must be positive")
        self._height = value
    @Property
    def area(self):
        return self._width * self._height
if __name__ == '__main__':
    rect = Rectangle(10, 20)
    print(rect.width)
    print(rect.height)
    print(rect.area)
    rect.width = 5
    rect.height = 10
    print(rect.width)
    print(rect.height)
    print(rect.area)
\end{lstlisting}
上面的程序输出结果如下所示：
\begin{lstlisting}[style=py,caption=, language=Python]

10
20
200
5
10
50
\end{lstlisting}
可以看到正确的输出了结果。
现在我们来好好分析一下我们在上面使用到的自己实现的 \verb|Property| 类是如何被调用的，在前面的内容当中我们已经讨论过了，只有类属性才可能是描述器，我们在使用 \verb|@Property| 的时候是获取到对应的函数，更准确的说是获得对象的 get 函数，然后使用 \verb|@Property| 的类当中的原来的函数就变成了 \verb|Property| 对象了，后面就可以使用对象的 \verb|setter| 方法了。
然后在使用 \verb|rect.width| 或者 \verb|rect.height| 方法的时候就活触发描述器的机制， rect 对象就会被传入到描述器的 \verb|__get__|方法，然后在这个方法当中将传入的对象再传给之前得到的 \verb|fget| 函数，就完美的实现了我们想要的效果。
\subsection{classmethod 和 staticmethod}
在 Python 中，staticmethod 和 classmethod 是两个常用的装饰器，它们分别用于定义静态方法和类方法。
\subsubsection{staticmethod}
staticmethod 是一个装饰器，它可以将一个函数定义为静态方法。静态方法与类实例无关，可以在不创建类实例的情况下直接调用，但它们仍然可以通过类名访问。
下面是一个简单的示例：
\begin{lstlisting}[style=py,caption=, language=Python]

class MyClass:
    @staticmethod
    def my_static_method(x, y):
        return x + y
print(MyClass.my_static_method(1, 2))
\end{lstlisting}
在这个示例中，我们定义了一个 MyClass 类，并使用 @staticmethod 装饰器将 my\_static\_method 方法定义为静态方法。然后我们可以通过 MyClass.my\_static\_method(1, 2) 直接调用该方法，而不需要创建 MyClass 的实例。需要注意的是，静态方法没有对类或实例进行任何修改，因此它们通常用于一些独立的、无状态的函数，或者在类中定义的一些帮助函数。
那么 staticmethod 是如何在语法层面实现的呢？这又离不开描述器了，在上面的代码当中我们使用 \verb|staticmethod| 装饰函数 \verb|my_static_method| 然后在类 \verb|MyClass| 当中会有一个类 staticmethod 的对象，且名字为 my\_static\_method 。我们需要注意到的是上面的过程用一行代码表示为 \verb|my_static_method = staticmethod(my_static_method)|，传入的 my\_static\_method 就是 my\_static\_method 函数，那么这就很简单了，当使用 my\_static\_method 的属性时候，我们可以在描述器的函数 \verb|__get__| 当中直接返回传入的函数即可。
我们自己实现的 StaticMethod 如下所示：
\begin{lstlisting}[style=py,caption=, language=Python]

class StaticMethod:
    "Emulate PyStaticMethod_Type() in Objects/funcobject.c"
    def __init__(self, f):
        self.f = f
        f = functools.update_wrapper(self, f)
    def __get__(self, obj, objtype=None):
        return self.f
    def __call__(self, *args, **kwds):
        return self.f(*args, **kwds)
\end{lstlisting}
我们使用上面自己实现的类：
\begin{lstlisting}[style=py,caption=, language=Python]

class MyClass(object):
    @StaticMethod
    def demo():
        return "demo"
if __name__ == '__main__':
    a = MyClass()
    print(a.demo())
\end{lstlisting}
上面的程序会输出字符串 \verb|"demo"| 。
\subsubsection{classmethod}
classmethod 是另一个装饰器，它可以将一个函数定义为类方法。类方法与静态方法类似，但它们接收的第一个参数是类对象而不是实例对象。类方法通常用于实现与类有关的操作，如工厂方法或构造函数。
下面是一个使用 classmethod 的示例：
\begin{lstlisting}[style=py,caption=, language=Python]

class MyClass:
    num_instances = 0
    
    def __init__(self):
        MyClass.num_instances += 1
    
    @classmethod
    def get_num_instances(cls):
        return cls.num_instances
obj1 = MyClass()
obj2 = MyClass()
print(MyClass.get_num_instances())
\end{lstlisting}
在这个示例中，我们定义了一个 MyClass 类，它包含一个类变量 num\_instances 和一个构造函数。然后，我们使用 @classmethod 装饰器将 get\_num\_instances 方法定义为类方法，并将 cls 参数用于访问类变量 num\_instances。
在创建 MyClass 的两个实例后，我们调用 MyClass.get\_num\_instances() 来获取当前创建的实例数。因为我们使用了类方法，所以可以直接通过类名调用该方法。
需要注意的是，类方法可以在类和实例之间共享，因为它们都可以访问类变量。另外，类方法可以被子类继承和重写，因为它们接收的第一个参数是类对象，而不是固定的类名。
在小节中，我们介绍了 Python 中的两种常用装饰器，即 staticmethod 和 classmethod。staticmethod 用于定义与类实例无关的静态方法，而 classmethod 用于定义与类相关的操作，如工厂方法或构造函数。两种装饰器都可以通过类名进行访问，但 classmethod 还可以被子类继承和重写，因为它们接收的第一个参数是类对象。
需要注意的是，staticmethod 和 classmethod 都可以被类或实例调用，但它们不同的是，classmethod 的第一个参数是类对象，而 staticmethod 没有这样的参数。因此，classmethod 可以访问类变量，而 staticmethod 不能访问类变量。
下面是一个更具体的比较：
\begin{lstlisting}[style=py,caption=, language=Python]

class MyClass:
    class_var = 'class_var'
    @staticmethod
    def static_method():
        print('This is a static method')
        
    @classmethod
    def class_method(cls):
        print('This is a class method')
        print(f'The class variable is: {cls.class_var}')
obj = MyClass()
# 静态方法可以被类或实例调用
MyClass.static_method()
obj.static_method()
# 类方法可以被类或实例调用，并且可以访问类变量
MyClass.class_method()
obj.class_method()
\end{lstlisting}
在这个示例中，我们定义了一个 MyClass 类，并分别定义了静态方法和类方法。在调用静态方法时，我们可以使用类名或实例名进行调用，因为静态方法与类或实例无关。而在调用类方法时，我们必须使用类名或实例名进行调用，并且类方法可以访问类变量。总的来说，staticmethod 和 classmethod 是 Python 中两个非常有用的装饰器，它们可以帮助我们更好地组织和管理代码。需要根据实际情况来选择使用哪种装饰器，以便实现最佳的代码设计和可维护性。
同样的道理我们可以实现自己的 ClassMethod
\begin{lstlisting}[style=py,caption=, language=Python]

class ClassMethod:
    "Emulate PyClassMethod_Type() in Objects/funcobject.c"
    def __init__(self, f):
        self.f = f
        functools.update_wrapper(self, f)
    def __get__(self, obj, cls=None):
        if cls is None:
            cls = type(obj)
        return MethodType(self.f, cls)
\end{lstlisting}
我们对上面的代码进行测试：
\begin{lstlisting}[style=py,caption=, language=Python]

class Myclass:
    @ClassMethod
    def demo(cls):
        return "demo"
if __name__ == '__main__':
    a = Myclass()
    print(a.demo())
\end{lstlisting}
上面的代码可以正确的输出字符串\verb|"demo"| 。
\subsection{总结}
在本小节当中主要给大家介绍了描述器的三个应用，仔细介绍了这三个类的使用方法，并且详细介绍了如何使用 python 实现同样的效果，这对于我们深入理解 python 面向对象编程非常有帮助，我们可以理解很多黑科技的内容，对于整个类的语法有更加深入的理解。


\section{描述器实现原理与源码分析}
在本小节当中主要给大家介绍描述器背后的实现原理，通过分析 cpython 对应的源代码了解与描述器相关的字节码的指令，我们就可以真正了解到描述器背后的原理！
\subsection{从字节码角度看描述器}
在前面的内容当中我们已经详细分析了描述器的使用和其相关的应用，我们通常使用描述器都是将其作为类的一个类属性使用，而使用的方式就是 \verb|a.attr|，而这个使用方式使用的字节码如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

Python 3.10.9 (main, Jan 11 2023, 09:18:18) [Clang 14.0.6 ] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import dis
>>> dis.dis("a.attr")
  1           0 LOAD_NAME                0 (a)
              2 LOAD_ATTR                1 (attr)
              4 RETURN_VALUE
>>>
\end{lstlisting}
可以看到的是真正调用的字节码是 \verb|LOAD_ATTR|，因此只需要我们深入 \verb|LOAD_ATTR| 指令我们就能够了解这其中所有发生的内容，了解魔法背后的神秘。
\subsection{描述器源码分析}
cpython 虚拟机当中执行这个字节码的内容如下：
\begin{lstlisting}[style=cpp,caption=, language=C++]

TARGET(LOAD_ATTR) {
    PyObject *name = GETITEM(names, oparg);
    PyObject *owner = TOP();
    PyObject *res = PyObject_GetAttr(owner, name);
    Py_DECREF(owner);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}
\end{lstlisting}
\verb|owner| 对应上面的代码当中的 \verb|a| 对象，\verb|name| 对应上面的字符串 \verb|attr| 。从上面的代码分析我们可以知道真正获取属性的函数为 \verb|PyObject_GetAttr| ，这个函数的源程序如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

PyObject *
PyObject_GetAttr(PyObject *v, PyObject *name)
{
    // 首先获取对象 v 的类型 ，对应上面的代码的话就是找到对象 a 的类型
    PyTypeObject *tp = Py_TYPE(v);
    if (!PyUnicode_Check(name)) {
        PyErr_Format(PyExc_TypeError,
                     "attribute name must be string, not '%.200s'",
                     name->ob_type->tp_name);
        return NULL;
    }
    // 获取对象的 tp_getattro 函数 这个函数就是负责属性查找的函数 我们一般使用的这个属性查找函数都是
    // object 这个基类的属性查找函数
    if (tp->tp_getattro != NULL)
        return (*tp->tp_getattro)(v, name);
    if (tp->tp_getattr != NULL) {
        const char *name_str = PyUnicode_AsUTF8(name);
        if (name_str == NULL)
            return NULL;
        return (*tp->tp_getattr)(v, (char *)name_str);
    }
    PyErr_Format(PyExc_AttributeError,
                 "'%.50s' object has no attribute '%U'",
                 tp->tp_name, name);
    return NULL;
}
\end{lstlisting}
在上面的代码当中我们提到了 object 这个基类，因为我们需要找到他的属性查找函数，因此我们看一下这个基类在 cpython 内部的定义，在 cpython 内部 object 基类定义为 \verb|PyBaseObject_Type|：
\begin{lstlisting}[style=cpp,caption=, language=C++]

PyTypeObject PyBaseObject_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
    "object",                                   /* tp_name */
    sizeof(PyObject),                           /* tp_basicsize */
    0,                                          /* tp_itemsize */
    object_dealloc,                             /* tp_dealloc */
    0,                                          /* tp_print */
    0,                                          /* tp_getattr */
    0,                                          /* tp_setattr */
    0,                                          /* tp_reserved */
    object_repr,                                /* tp_repr */
    0,                                          /* tp_as_number */
    0,                                          /* tp_as_sequence */
    0,                                          /* tp_as_mapping */
    (hashfunc)_Py_HashPointer,                  /* tp_hash */
    0,                                          /* tp_call */
    object_str,                                 /* tp_str */
    // 这个就是真正的属性查找函数
    PyObject_GenericGetAttr,                    /* tp_getattro */
    PyObject_GenericSetAttr,                    /* tp_setattro */
    0,                                          /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
    PyDoc_STR("object()\n--\n\nThe most base type"),  /* tp_doc */
    0,                                          /* tp_traverse */
    0,                                          /* tp_clear */
    object_richcompare,                         /* tp_richcompare */
    0,                                          /* tp_weaklistoffset */
    0,                                          /* tp_iter */
    0,                                          /* tp_iternext */
    object_methods,                             /* tp_methods */
    0,                                          /* tp_members */
    object_getsets,                             /* tp_getset */
    0,                                          /* tp_base */
    0,                                          /* tp_dict */
    0,                                          /* tp_descr_get */
    0,                                          /* tp_descr_set */
    0,                                          /* tp_dictoffset */
    object_init,                                /* tp_init */
    PyType_GenericAlloc,                        /* tp_alloc */
    object_new,                                 /* tp_new */
    PyObject_Del,                               /* tp_free */
};
// 从上面的 object 定义可以看到真正的查找函数为 PyObject_GenericGetAttr 其函数内容如下所示：
PyObject *
PyObject_GenericGetAttr(PyObject *obj, PyObject *name)
{
    return _PyObject_GenericGetAttrWithDict(obj, name, NULL, 0);
}
\end{lstlisting}
\verb|_PyObject_GenericGetAttrWithDict| 函数定义如下所示：
\begin{lstlisting}[style=cpp,caption=, language=C++]

/* Generic GetAttr functions _mmput these in your tp_[gs]etattro slot. */ 
PyObject *
_PyObject_GenericGetAttrWithDict(PyObject *obj, PyObject *name,
                                 PyObject *dict, int suppress)
{
    /* Make sure the logic of _PyObject_GetMethod is in sync with
       this method.
       When suppress=1, this function suppress AttributeError.
    */
    // 首先获取对象的类型 针对于上面的源代码来说就是找到对象 a 的类型
    PyTypeObject *tp = Py_TYPE(obj);
    PyObject *descr = NULL;
    PyObject *res = NULL;
    descrgetfunc f;
    Py_ssize_t dictoffset;
    PyObject **dictptr;
    if (!PyUnicode_Check(name)){
        PyErr_Format(PyExc_TypeError,
                     "attribute name must be string, not '%.200s'",
                     name->ob_type->tp_name);
        return NULL;
    }
    Py_INCREF(name);
    if (tp->tp_dict == NULL) {
        if (PyType_Ready(tp) < 0)
            goto done;
    }
    // 这个是从所有的基类当中找到一个名字为 name 的对象 如果没有就返回 NULL
    // 这里的过程还是比较复杂 需要从类的 mro 序列当中进行查找
    descr = _PyType_Lookup(tp, name);
    f = NULL;
    // 如果找到的类对象不为空 也就是在类本身或者基类当中找到一个名为 name 的对象
    if (descr != NULL) {
        Py_INCREF(descr);
        // 得到类对象的 __get__ 函数
        f = descr->ob_type->tp_descr_get;
        // 如果对象有 __get__ 函数则进行进一步判断
        if (f != NULL && PyDescr_IsData(descr)) { // PyDescr_IsData(descr) 这个宏是查看对象是否有 __set__ 函数
            // 如果是类对象又有 __get__ 函数 又有 __set__ 函数 则直接调用对象的 __get__ 函数 并且将结果返回
            // 这里需要注意一下优先级 这个优先级是最高的 如果一个类对象定义了 __set__ 和 __get__ 函数，那么
            // 就会直接调用类对象的 __get__ 函数并且将这个函数的返回值返回
            res = f(descr, obj, (PyObject *)obj->ob_type);
            if (res == NULL && suppress &&
                    PyErr_ExceptionMatches(PyExc_AttributeError)) {
                PyErr_Clear();
            }
            goto done;
        }
    }
    // 如果没有名为 name 的类对象 或者虽然有名为 name 的对象 但是只要没有同时定义 __get__ 和 __set__ 函数就需要
    // 继续往下执行 从对象本省的 dict 当中寻找
    if (dict == NULL) {
        /* Inline _PyObject_GetDictPtr */
        // 这部分代码就是从对象 obj 当中找到对象的 __dict__ 字段
        dictoffset = tp->tp_dictoffset;
        if (dictoffset != 0) {
            if (dictoffset < 0) {
                Py_ssize_t tsize;
                size_t size;
                tsize = ((PyVarObject *)obj)->ob_size;
                if (tsize < 0)
                    tsize = -tsize;
                size = _PyObject_VAR_SIZE(tp, tsize);
                assert(size <= PY_SSIZE_T_MAX);
                dictoffset += (Py_ssize_t)size;
                assert(dictoffset > 0);
                assert(dictoffset % SIZEOF_VOID_P == 0);
            }
            dictptr = (PyObject **) ((char *)obj + dictoffset);
            dict = *dictptr;
        }
    }
    // 如果对象 obj 存在 __dict__ 字段 那么就返回 __dict__ 字段当中名字等于 name 的对象
    if (dict != NULL) {
        Py_INCREF(dict);
        res = PyDict_GetItem(dict, name);
        if (res != NULL) {
            Py_INCREF(res);
            Py_DECREF(dict);
            goto done;
        }
        Py_DECREF(dict);
    }
    // 如果类对象定义了 __get__ 函数没有定义 __set__ 函数而且在 dict 当中没有找到名为 name 的对象的话
    // 那么久调用类对象的 __get__ 函数
    if (f != NULL) {
        res = f(descr, obj, (PyObject *)Py_TYPE(obj));
        if (res == NULL && suppress &&
                PyErr_ExceptionMatches(PyExc_AttributeError)) {
            PyErr_Clear();
        }
        goto done;
    }
    // 如果类对象没有定义 __get__ 函数那么就直接将这个类对象返回
    if (descr != NULL) {
        res = descr;
        descr = NULL;
        goto done;
    }
    if (!suppress) {
        PyErr_Format(PyExc_AttributeError,
                     "'%.50s' object has no attribute '%U'",
                     tp->tp_name, name);
    }
  done:
    Py_XDECREF(descr);
    Py_DECREF(name);
    return res;
}
\end{lstlisting}
根据对上面的程序进行分析，我们可以到得到从对象当中获取属性的顺序和优先级如下所示（以 \verb|a.attr| 为例子）：
\begin{itemize}
\item 如果属性不是类属性，那么很简单就是直接从对象本身的 \verb|__dict__| 当中获取这个对象。 
\item 如果属性是类属性，如果同时定义了 \verb|__get__| 和 \verb|__set__| 函数，那么就会调用这个类对象的 \verb|__get__| 函数，将这个函数的返回值作为 \verb|a.attr| 的返回值。 
\item 如果属性是类属性，如果只定义了 \verb|__get__| 函数，那么就会从对象 \verb|a| 本身的 \verb|__dict__| 当中获取 \verb|attr| ，如果 \verb|attr| 存在与 \verb|a.__dict__| 当中，那么久返回这个结果，如果不存在的话那么就会调用 \verb|__get__| 函数，将这个函数的返回值作为 \verb|a.attr| 的结果，如果连 \verb|__get__| 都没有定义，那么就会直接返回这个类对象。 
\end{itemize}
上面的函数过程用 python 语言来描述的话如下所示：
\begin{lstlisting}[style=py,caption=, language=Python]

def find_name_in_mro(cls, name, default):
    "Emulate _PyType_Lookup() in Objects/typeobject.c"
    for base in cls.__mro__:
        if name in vars(base):
            return vars(base)[name]
    return default
def object_getattribute(obj, name):
    "Emulate PyObject_GenericGetAttr() in Objects/object.c"
    null = object()
    objtype = type(obj)
    cls_var = find_name_in_mro(objtype, name, null)
    descr_get = getattr(type(cls_var), '__get__', null)
    if descr_get is not null:
        if (hasattr(type(cls_var), '__set__')
            or hasattr(type(cls_var), '__delete__')):
            return descr_get(cls_var, obj, objtype)     # data descriptor
    if hasattr(obj, '__dict__') and name in vars(obj):
        return vars(obj)[name]                          # instance variable
    if descr_get is not null:
        return descr_get(cls_var, obj, objtype)         # non-data descriptor
    if cls_var is not null:
        return cls_var                                  # class variable
    raise AttributeError(name)
\end{lstlisting}
仔细分析上面的 python 代码，他的整个逻辑和我们前面分析的 c 代码的逻辑是一样的。首先是获取对象的类型，然后从类型当中获取名字为 name 的属性，如果类属性定义了 \verb|__get__| 函数，则需要进行描述器的判断，否则直接从对象的 \verb|__dict__| 当中获取，如果其中没有则返回类对象。
\subsection{总结}
在本小节当中主要给大家深入分析了在 cpython 的内部对于描述器的实现原理，其中最重要的就是在获取属性的时候的优先级了。我们直接从 c 代码的层面分析了整个获取属性的优先级，并且给出了 python 层面的代码帮助大家理解。